<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://BUAA-Wander.github.io</id>
    <title>WanderOvO</title>
    <updated>2025-11-01T03:55:40.317Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://BUAA-Wander.github.io"/>
    <link rel="self" href="https://BUAA-Wander.github.io/atom.xml"/>
    <subtitle>写点代码玩玩</subtitle>
    <logo>https://BUAA-Wander.github.io/images/avatar.png</logo>
    <icon>https://BUAA-Wander.github.io/favicon.ico</icon>
    <rights>All rights reserved 2025, WanderOvO</rights>
    <entry>
        <title type="html"><![CDATA[2025年10月算法好题集锦]]></title>
        <id>https://BUAA-Wander.github.io/post/2025-10-good-problems/</id>
        <link href="https://BUAA-Wander.github.io/post/2025-10-good-problems/">
        </link>
        <updated>2025-10-02T01:09:57.000Z</updated>
        <content type="html"><![CDATA[<p>Codeforces：</p>
<blockquote>
<p>gym 中题目难度分是我根据体感估计的。</p>
</blockquote>
<table>
<thead>
<tr>
<th>题目链接</th>
<th>难度分</th>
<th>Tag</th>
<th>题解</th>
<th>学到的东西</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://codeforces.com/contest/1142/problem/B">CF1142B</a></td>
<td>2000</td>
<td>倍增、破环为链</td>
<td>---</td>
<td>这是在一个<strong>结构</strong>上倍增<strong>跳步</strong>的问题，需要预处理跳若干步之后跳到了哪里。另外本题可以离线做，也可以在线做</td>
</tr>
<tr>
<td><a href="https://codeforces.com/problemset/problem/1848/F">CF1848F</a></td>
<td>2400</td>
<td>倍增、打表</td>
<td></td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo><mtext> </mtext><mo>⊕</mo><mtext> </mtext><mi>a</mi><mo>[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">a[i] = a[i]\  \oplus\ a[i + 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace"> </span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace"> </span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 这个条件在很多题中会遇到，如果所有数一起做的话，做 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>j</mi></msup></mrow><annotation encoding="application/x-tex">2^j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span></span></span></span> 轮之后会变成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo><mtext> </mtext><mo>⊕</mo><mtext> </mtext><mi>a</mi><mo>[</mo><mi>i</mi><mo>+</mo><msup><mn>2</mn><mi>j</mi></msup><mo>]</mo></mrow><annotation encoding="application/x-tex">a[i] = a[i]\  \oplus\ a[i + 2^j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace"> </span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace"> </span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0746639999999998em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>。这个规律可以通过打表找出来。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/problemset/problem/1515/E">CF1515E</a></td>
<td>2200</td>
<td>DP、组合数学</td>
<td></td>
<td>需要敏锐地发现可以按照自动打开的灯分段，然后分别计算每段自己的方案数以及和前面的段组合的方案数，这两个方案数的计算都是组合数学的典型模型。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/104679/problem/F">CF104679F</a></td>
<td>1700</td>
<td>位运算、构造</td>
<td></td>
<td>被我忽略的一个关键点在于，假如目前选的数异或出来是某个 <code>val</code>，则其和目标值 <code>target</code> 之间<strong>仅差一步就可以转化过去</strong>。异或的这个特点在其他题里也会遇到，经常用于前面若干个随便选，只用最后一个来调整结果。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/104679/problem/E">CF104679E</a></td>
<td>1600</td>
<td>数论</td>
<td></td>
<td>又是一道数论与图论结合的题目，值得注意的点在于本题输入一个数输出一个数，并且有很显然的暴力做法， 所以完全可以本地对拍过之后再提交。本题恰好在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 比较小的时候比较特殊，对拍能找到问题。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/104822/problem/I">CF104822I</a></td>
<td>1900</td>
<td>数论</td>
<td></td>
<td>首先要把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(a + b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span> 整除 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">ab</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span></span></span></span> 转化为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(a + b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span> 整除 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">a^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>，这样转化的目的是有一边固定下来了。后边涉及到<strong>素因数分解之后反求出约数</strong>，这个只需要设一个约数集合 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>=</mo><mo>{</mo><mn>1</mn><mo>}</mo></mrow><annotation encoding="application/x-tex">S = \{1\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">1</span><span class="mclose">}</span></span></span></span>，然后枚举素因数及其次数，和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> 中已有的乘起来，每完成一个素因数的计算就把新得到的因数加到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> 中。这样复杂度是不高的，因为约数个数本身也就小几百个，而我们每次计算必然会增加一个新的之前没得到的约数。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/104328/problem/D">CF104328D</a></td>
<td>1800</td>
<td>数论、树形DP</td>
<td></td>
<td>本质上是求树的满足一定性质的<strong>直径</strong>，可以枚举直径的最高点，然后枚举直径中应该包含的素因子是谁，去做 DP 即可。这里需要注意<strong>一个数的素因子种类数并不多</strong>，常见的数据范围内也就 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span> 个左右。还需要注意一个点就是快速素因数分解的复杂度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>log</mi><mo>⁡</mo><mi>M</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\log M)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span>，也是比较快的，因此这个题才可以这样做。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/104380/problem/F">CF104380F</a></td>
<td>1600</td>
<td>构造、贪心、堆</td>
<td></td>
<td>首先要敏锐的观察到，往 deque 中插数据时，最后一个数要么在做最左边，要么在最右边，所以做不到无脑把最大的那些数放到想要的位置。然后会想到假如钦定不要某个后缀被选了，能否让剩下的前缀取到理论上的最大值，发现只要枚举后缀，然后看前缀往左还是往右放就好了。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/105486/problem/I">CF105485I</a></td>
<td>1800</td>
<td>数论、线段树</td>
<td></td>
<td>当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>gcd</mi><mo>⁡</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\gcd = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mop"><span style="margin-right:0.01389em;">g</span>cd</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 时，答案应该输出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，这个点被我疏忽了，之后通过对拍和猜测这两种方式分别找到了 bug。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/103855/problem/D">CF103855D</a></td>
<td>1800</td>
<td>分类讨论、贪心</td>
<td></td>
<td>最开始想了一个<strong>错误的贪心</strong>，但还好写之前就自己构造数据 hack 了自己。然后发现其实本质上就是拿 0 和 3 以及拿 1 和 2 这两类情况，只要分类讨论就好了，这时<strong>又想了一个错误的贪心</strong>（1 拿最大的），但也反应过来不对了，发现还是得枚举 1 到底拿谁。还是要多造数据去验证想法的正确性。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/102409/problem/J">CF102409J</a></td>
<td>1600</td>
<td>枚举、贪心、证明</td>
<td></td>
<td>可以想到多种枚举方式。枚举第一个分割点后贪心正确性存疑，枚举第二个点后左右评分容易证明正确性。另外可以快速写一个对拍验证正确性。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/102419/problem/D">CF102419D</a></td>
<td>1800</td>
<td>二分图判定、测试、教学</td>
<td></td>
<td><strong>一道用于说明随机数据测试并非万能的好题</strong>！由于这道题目的特殊性，我们可以本地验证答案是否正确，就容易想到随机生成数据去测，测完再提交。但一方面，这个题多一个 <code>log</code> 是过不去的，本地小数据测不出来（TLE）；另一方面，本题的值域严格卡到了 <code>1 &lt;&lt; 20</code>，如果只开 <code>1e6</code> 是过不了的（RE）。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/contest/691/problem/E">CF691E</a></td>
<td>1900</td>
<td>矩阵快速幂、DP、教学</td>
<td></td>
<td>入门题，以后讲课可以扔到例题里。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/problemset/problem/1117/D">CF1117D</a></td>
<td>2100</td>
<td>矩阵快速幂、DP、教学</td>
<td></td>
<td>更入门的矩阵快速幂。注意计算方案数的题目要同时看一下 DP 和组合数学方法，都去试一试。组合数学方法不好算时，说不定 DP 能快速幂优化解决。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/104848/problem/M">CF104848M</a></td>
<td>1900+</td>
<td>柯西不等式、最短路、教学</td>
<td><a href="https://github.com/Yawn-Sean/Daily_CF_Problems/blob/main/daily_problems/2025/10/1018/solution/cf104848m.md">题解</a></td>
<td>可以弱化成链上的问题，用来吸引学数学竞赛的人来搞 OI。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/105408/problem/G">CF105408G</a></td>
<td>1500</td>
<td>数论、教学、测试</td>
<td></td>
<td>本题是一个很好的说明<strong>随机数据可能测不全</strong>的例子，因为想随机出两两 GCD 一样的数组，在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 稍微大一点或者值域稍微大一点时很困难。另外，本题在 YES 的情况时，时间复杂度会卡满，本地随机测试几乎测不到这种情况，这时需要先生成一个 gcd，然后选一堆素数和其相乘，就可以构造出一个 YES 的情况。实测某些看似能过的做法会在 YES 的时候 TLE 掉。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/problemset/gymProblem/103886/G">CF103886G</a></td>
<td>1800</td>
<td>分治、构造</td>
<td></td>
<td><strong>按二进制位分治</strong>。如果把奇数放左边，偶数放右边，则不可能存在题中所说的跨左右两段的三元组，从而只需要分别考虑左右两边，递归下去，只要再按照更高的二进制位进行分类即可。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/105335/problem/I">CF105335I</a></td>
<td>2000</td>
<td>康托展开、树状数组二分、教学</td>
<td><a href="https://github.com/Yawn-Sean/Daily_CF_Problems/blob/main/daily_problems/2025/10/1021/solution/cf105335i.md">题解</a></td>
<td>首先要知道咋算一个排列的排名，然后需要把后边那个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>n</mi><mo>!</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{n!}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mclose mtight">!</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 合并到前面的项中，从而也转化成“<strong>每个数在后缀中排名多少</strong>”这个信息，只要有了这个信息，使用一个有序结构从左到右搞一搞就可以构造出排列了。注意，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>n</mi><mo>!</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{n!}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mclose mtight">!</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 这种极大的数很难直接用除法算排名，所以只能像上面那样搞排名。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/105582/problem/C">CF105582C</a></td>
<td>1800</td>
<td>DP、二分、多重背包、优化教学</td>
<td></td>
<td>首先容易想到一个裸的 DP 去看凑出质量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 的集合至多多少个，但是这个 DP 的状态不太能优化。考虑到答案有单调性，可以二分。二分之后，我们相当于限定了一个集合中每种零件至多用多少个，这样就成了裸的多重背包问题。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/106125/problem/E">CF106125E</a></td>
<td>1600</td>
<td>随机、乱搞、骗分、教学</td>
<td><a href="https://github.com/Yawn-Sean/Daily_CF_Problems/blob/main/daily_problems/2025/10/1025/solution/cf106125e.md">题解</a></td>
<td>练习一下乱搞。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/106125/problem/F">CF106125F</a></td>
<td>2100</td>
<td>补图、二分图、DP、测试、教学</td>
<td></td>
<td>容易发现 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 比较小的时候才有解，这个时候图非常稠密，接近一个完全图。考虑两个点是否在一个集合是困难的，但是两个点不在同一个集合这个事情似乎是容易做的。考虑补图，补图上的边代表互斥关系，则补图是二分图时必有点没法放到任何一个集合里。另外由于要求两个集合一样大，所以需要 DP 求具体方案。本题可以本地写 spj 测试，数据生成的时候建议生成点数少且边数多的图，或从完全图上删少量的边，<strong>纯随机数据测会不可以总司令</strong>。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/contest/703/problem/D">CF703D</a></td>
<td>2100</td>
<td>离线、树状数组</td>
<td></td>
<td>首先区间异或和是可以前缀异或和求出来的，然后区间中出现偶数次的数是不贡献到区间异或和里的，进而发现<strong>区间异或和就是区间中出现奇数次的数的异或和</strong>（无需去重）。区间中所有数字去重的异或和，再异或上出现奇数次的数的异或和，就是偶数次的数去重的异或和了。<strong>所有数去重的异或和</strong>可以类比<strong>区间中不同数的个数</strong>的做法（HH 的项链）去维护。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/problemset/problem/2001/D">CF2001D</a></td>
<td>1900</td>
<td>线段树、单调栈、树状数组、双指针、测试、教学</td>
<td><a href="https://docs.qq.com/sheet/DWGFoRGVZRmxNaXFz?tab=BB08J2">题解</a></td>
<td>本题如果使用一种错误的单调队列写法，<strong>本地对拍测试时有可能需要 1 分钟左右才能拍出 bug</strong>，这个错误做法提交后也能通过多测的 4 组测试点，算是比较隐蔽的 bug 了。使用线段树实现查询是正确的，但是比较长。小清新做法是使用单调栈，灵神最喜欢的数据结构。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/104901/problem/K">CF104901K</a></td>
<td>2100</td>
<td>树状数组、中位数贪心、双指针、二分</td>
<td></td>
<td><strong>一段数组每个比上一个大 1，则每个数减掉自己的下标之后应该相等</strong>，这是个比较经典的套路。我们相当于想让一段 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>−</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">a[i] - i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 相等，这个使用绝对值不等式可知最小操作次数就是改成中位数。求中位数可以树状数组二分去做。如何计算代价呢？只要分别维护比中位数小的数的和，以及更大的数的和就好了。如果外边套二分答案则是双 log，过不去，需要把二分答案改成双指针。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/problemset/gymProblem/106054/B">CF106054B</a></td>
<td>2000</td>
<td>组合数学、隔板法</td>
<td></td>
<td>根据 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 数组，可以求出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 中相隔 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 项的两个数之间的差的关系，只要确定了前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 个数，后边的就都确定了，关键是根据这个关系算出来前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 个数的下界，然后就是隔板法计算了。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/problemset/problem/134/B">CF134B</a></td>
<td>1900</td>
<td>辗转相除法、数论、教学</td>
<td></td>
<td>考辗转相除法求 gcd 的过程的题目。反着来看，看 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>n</mi><mo separator="true">,</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(n, x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 如何变成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(1, 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，题目所给的这个过程就类似于求 gcd 的过程，能变成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(1, 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 说明两个数得互素，在求 gcd 的过程中顺便统计一下操作次数就好了。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/104785/problem/K">CF104785K</a></td>
<td>1700</td>
<td>图论、脑筋急转弯</td>
<td></td>
<td>选一些边，则选择的边构成的集合和剩下的边构成的集合，至少有一个的大小是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>m</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{m}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，所以我们可以想办法将边分成这两类，每类内部都无环，则总有一个是符合题意的。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/problemset/problem/2129/B">CF2129B</a></td>
<td>1600</td>
<td>逆序对</td>
<td></td>
<td>首先要知道 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>n</mi><mo>−</mo><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>≥</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">2n - p[i] \ge n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>。倘若我们按 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">p[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 从小到大的顺序去考虑变还是不变，如果不变，则其他所有还没填的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">p[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 变或者不变都一定比 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">p[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 大，所以只要考虑左边还没填的贡献答案就好；如果变了，则其他所有还没填的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">p[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 不管变还是不变，都一定比 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>n</mi><mo>−</mo><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">2n - p[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 小，所以只要考虑右边的就好了。这样相当于考虑 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">p[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 和还没填的数构成的逆序数，<strong>把逆序数记到先填的数头上</strong>，就不重不漏了，且可以独立考虑，就容易做了。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/106144/problem/F">CF106144F</a></td>
<td>1600</td>
<td>博弈、测试</td>
<td></td>
<td>根据博弈论最基本的判断先手必胜还是必败的原理，我们可以写一个 DP。这个题数据范围比较大，DP 只能做一小部分，但是能辅助我们检查猜测的结论是否正确，对拍一下就知道了。</td>
</tr>
</tbody>
</table>
<p>其他题目：</p>
<table>
<thead>
<tr>
<th>题目链接</th>
<th>难度分</th>
<th>Tag</th>
<th>题解</th>
<th>学到的东西</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://www.luogu.com.cn/problem/P12247">P12247</a></td>
<td>上位绿</td>
<td>扫描线、堆、DP</td>
<td><a href="https://www.luogu.com.cn/problem/solution/P12247">P12247</a></td>
<td>一道很综合的题目，首先要想到在<strong>时间轴</strong>上去 DP，写出朴素的转移方程，然后发现需要一个查询最大值的结构，且需要排除过期元素，用扫描线的思想+懒删除实现过期删除，也可以使用 <code>multiset</code> 直接实现随机删除和查询最大值，常数可能会大一点。</td>
</tr>
<tr>
<td><a href="https://www.luogu.com.cn/problem/T673603">T673603</a></td>
<td>上位绿</td>
<td>逆序对、树状数组、贡献法</td>
<td><a href="https://www.luogu.com.cn/paste/yz58xx5w">题解+std</a></td>
<td><strong>邻项交换次数</strong>和<strong>逆序对</strong>关联很大，所以首先要想到这个事情。第二个事情，重排得到山脉数组可以看成是从小到大考虑所有数，每次塞到左边或者右边。第三个事情，由于交换次数就是求逆序对，所以我们考虑每个数字头上有多少次交换（即多少逆序数），为了不重不漏可以钦定把贡献<strong>记到小的数头上</strong>。</td>
</tr>
<tr>
<td><a href="https://www.luogu.com.cn/problem/P7113">P7113</a></td>
<td>黄</td>
<td>拓扑排序、<code>__int128_t</code></td>
<td></td>
<td>学一下怎么用 <code>__int128_t</code>，本题不用这个过不了（怪题），以及手写分数结构体及其操作。并且需要注意 <code>__int128_t</code> 需要模拟<strong>逐位输出</strong>，不要在关闭流同步时<strong>混用输出方式</strong>。</td>
</tr>
<tr>
<td><a href="https://www.luogu.com.cn/problem/P2536">P2536</a></td>
<td>绿</td>
<td>DP</td>
<td></td>
<td>注意 DP 初始化，本题中所有的 <code>dp[i][0]</code> 和 <code>dp[0][j]</code> 都需要初始化。写 DP 时要检查每个值的前序值是否真的都算过/初始化过了。</td>
</tr>
<tr>
<td><a href="https://www.luogu.com.cn/problem/P4768">P4768</a></td>
<td>紫</td>
<td>kruskal重构树、倍增、最短路、强制在线</td>
<td></td>
<td>学习了kruskal重构树的模板以及应用，并深深体会到了<strong>强制在线对题目难度的巨大影响</strong>。以及，多组数据一定要检查是不是清空了！这个题涉及到的数据很多，做的时候<strong>多测没有完全清空</strong>，使用 <code>memset</code> 二分清空才发现到底是哪个东西忘了清了。</td>
</tr>
<tr>
<td><a href="https://www.luogu.com.cn/problem/T673604">T673604</a></td>
<td>蓝</td>
<td>分治、按位贪心、Trie</td>
<td><a href="https://www.luogu.com.cn/paste/yz58xx5w">题解+std</a></td>
<td>题目给出了正着构造的规则，但要求倒退回去有多少可能的来源，这需要我们先分析正着构造的性质。</td>
</tr>
<tr>
<td><a href="https://www.luogu.com.cn/problem/P4059">P4059</a></td>
<td>上位绿</td>
<td>DP、转化、初始化</td>
<td></td>
<td>首先这个题目要注意到连续空格的贡献是一次函数，倘若只是正比例函数那么相当于每个空格贡献是<strong>常数</strong>，一次函数的话只是第一次比较特殊，后边的贡献都一样。第二个要注意的点在于<strong>初始化</strong>，本题的初始化比较麻烦，需要分析好。</td>
</tr>
<tr>
<td><a href="https://atcoder.jp/contests/abc180/tasks/abc180_e">ABC180E</a></td>
<td>绿</td>
<td>状压DP、证明</td>
<td></td>
<td>本题值得学习的点在于证明每个点只需要走恰好一次，证明的关键是发现两点之间的距离函数满足三角形不等式，所以任何重复访问都是不优的。</td>
</tr>
<tr>
<td><a href="https://www.luogu.com.cn/problem/P4926">P4926</a></td>
<td>蓝</td>
<td>差分约束</td>
<td></td>
<td>建模细节非常多的一个题。首先二分答案是显然的；然后需要把乘法约束取对数变成加法约束，才能转化成差分约束，这样会导致二分上界受到第一种承诺的约束；接着，初值点需要使用超级源点建立等式约束，没给初值的点也需要加入单向 0 边保证能遍历到，这样才能把所有约束都考虑进来。</td>
</tr>
<tr>
<td><a href="https://www.luogu.com.cn/problem/T676142">T676142</a></td>
<td>绿</td>
<td>DP、组合数学、测试</td>
<td></td>
<td>赛时对拍都过了，思路也很流畅，最后挂了 30 分，原因是有个地方取模没取上，而<strong>对拍只拍了小数据</strong>，还是赖自己没有仔细检查溢出的情况（取模也是一种溢出），太可惜了。</td>
</tr>
<tr>
<td><a href="https://www.luogu.com.cn/problem/P1939">P1939</a></td>
<td>绿</td>
<td>矩阵快速幂</td>
<td></td>
<td>其实是一个模板题，但是这里我才算是第一次知道<strong>咋写转移矩阵</strong>。我们注意到递推公式里包含 3 个数，于是我们考虑怎么从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>−</mo><mn>3</mn></mrow></msub><mo separator="true">,</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>−</mo><mn>2</mn></mrow></msub><mo separator="true">,</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(a_{i - 3}, a_{i - 2}, a_{i - 1})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 转移到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>−</mo><mn>2</mn></mrow></msub><mo separator="true">,</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>a</mi><mi>i</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(a_{i - 2}, a_{i - 1}, a_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，考虑给第一个列向量左乘一个矩阵得到第二个向量，那么根据待定系数法 + 对应项相等，就知道了这个转移矩阵的具体值。</td>
</tr>
<tr>
<td><a href="https://www.luogu.com.cn/problem/P10499">P10499</a></td>
<td>蓝</td>
<td>高斯消元</td>
<td></td>
<td>主要是<strong>问题建模</strong>。我们考虑对于第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个开关，主动按哪些开关时会让这个开关的状态也变化。这样的话，假如我们知道每个开关到底按没按，只需要把这两个东西做一个对应位置的与操作，再把与的结果异或起来（类似内积先乘后加），就是最终经过这些操作后到底改没改变这个开关的状态了。</td>
</tr>
<tr>
<td><a href="https://www.luogu.com.cn/problem/T676143">T676143</a></td>
<td>蓝</td>
<td>ST表、括号序列、哈希、二分</td>
<td></td>
<td>积累了两个技巧：第一个是左右括号数量相等的括号序列<strong>仅通过循环移位</strong>就可以使之合法，第二个是比较一个字符串的两个子串的字典序，可以用<strong>哈希+二分</strong>求出这两个子串第一个不一样的位置，然后比较这个位置的字符，这样无需暴力比较了。</td>
</tr>
<tr>
<td><a href="https://www.luogu.com.cn/problem/P9043">P9043</a></td>
<td>绿</td>
<td>复杂键哈希、双指针、分类讨论、推式子</td>
<td></td>
<td>一种和两种字符的情况有很多办法可以做，关键是如何解决三种字符的情况。三个相等其实可以转化成两对两个相等，例如 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi><mo>[</mo><mi>r</mi><mo>]</mo><mo>[</mo><mi>a</mi><mo>]</mo><mo>−</mo><mi>c</mi><mi>n</mi><mi>t</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>a</mi><mo>]</mo><mo>=</mo><mi>c</mi><mi>n</mi><mi>t</mi><mo>[</mo><mi>r</mi><mo>]</mo><mo>[</mo><mi>b</mi><mo>]</mo><mo>−</mo><mi>c</mi><mi>n</mi><mi>t</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>b</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">cnt[r][a] - cnt[l][a] = cnt[r][b] - cnt[l][b]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">b</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">b</span><span class="mclose">]</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi><mo>[</mo><mi>r</mi><mo>]</mo><mo>[</mo><mi>b</mi><mo>]</mo><mo>−</mo><mi>c</mi><mi>n</mi><mi>t</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>b</mi><mo>]</mo><mo>=</mo><mi>c</mi><mi>n</mi><mi>t</mi><mo>[</mo><mi>r</mi><mo>]</mo><mo>[</mo><mi>c</mi><mo>]</mo><mo>−</mo><mi>c</mi><mi>n</mi><mi>t</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>c</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">cnt[r][b] - cnt[l][b] = cnt[r][c] - cnt[l][c]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">b</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">b</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">c</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">c</span><span class="mclose">]</span></span></span></span>，变形成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi><mo>[</mo><mi>r</mi><mo>]</mo><mo>[</mo><mi>a</mi><mo>]</mo><mo>−</mo><mi>c</mi><mi>n</mi><mi>t</mi><mo>[</mo><mi>r</mi><mo>]</mo><mo>[</mo><mi>b</mi><mo>]</mo><mo>=</mo><mi>c</mi><mi>n</mi><mi>t</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>a</mi><mo>]</mo><mo>−</mo><mi>c</mi><mi>n</mi><mi>t</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>b</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">cnt[r][a] - cnt[r][b] = cnt[l][a] - cnt[l][b]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">b</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">b</span><span class="mclose">]</span></span></span></span>，然后发现可以维护 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>c</mi><mi>n</mi><mi>t</mi><mo>[</mo><mi>a</mi><mo>]</mo><mo>−</mo><mi>c</mi><mi>n</mi><mi>t</mi><mo>[</mo><mi>b</mi><mo>]</mo><mo separator="true">,</mo><mi>c</mi><mi>n</mi><mi>t</mi><mo>[</mo><mi>b</mi><mo>]</mo><mo>−</mo><mi>c</mi><mi>n</mi><mi>t</mi><mo>[</mo><mi>c</mi><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">(cnt[a] - cnt[b], cnt[b] - cnt[c])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">b</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">b</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">c</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span> 的二元组的个数就好了，只要两个二元组相等，就说明这个串是可以的。</td>
</tr>
<tr>
<td><a href="https://www.luogu.com.cn/problem/P8806">P8806</a></td>
<td>绿</td>
<td>DP、贪心、证明、骗分、教学</td>
<td></td>
<td>证明为什么按照 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mo>+</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">w + v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span> 排序，以及如果没有证明出来，有什么骗分的办法，以及如何检测（对拍）。</td>
</tr>
<tr>
<td><a href="https://www.luogu.com.cn/problem/P8817">P8817</a></td>
<td>蓝</td>
<td>BFS、暴力、测试</td>
<td></td>
<td>本题对拍时测出来设置的无穷大不够大，因为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 有可能超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 很小但 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 比较大时，设置最短路为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 就会有问题。另外本题在做的时候中间一次关键的代码修改导致复杂度变成了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>3</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，需要进一步优化才能通过本题。</td>
</tr>
</tbody>
</table>
<p>看到的有意思的东西：</p>
<ul>
<li><a href="https://www.xiaohongshu.com/explore/68cd977d000000001300e55e?xsec_token=ABYfpW1DPd3BQZ8r26rPygSxPPYgk9hDxTbQOjSid_O_E=&amp;xsec_source=pc_user">ICPC常用组合数公式与技巧 - 小红书</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/494875993">代码源每日一题 Div1 括号序列 - 知乎</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2025年9月算法好题集锦]]></title>
        <id>https://BUAA-Wander.github.io/post/2025-09-good-problems/</id>
        <link href="https://BUAA-Wander.github.io/post/2025-09-good-problems/">
        </link>
        <updated>2025-09-01T01:27:22.000Z</updated>
        <content type="html"><![CDATA[<p>Codeforces：</p>
<blockquote>
<p>*表示对 gym 中题目难度的估计。</p>
</blockquote>
<table>
<thead>
<tr>
<th>题目链接</th>
<th>难度分</th>
<th>Tag</th>
<th>题解</th>
<th>学到的东西</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://codeforces.com/contest/1900/problem/D">CF1900D</a></td>
<td>2000</td>
<td>数论、容斥</td>
<td>---</td>
<td>学习去掉倍数的重复情况</td>
</tr>
<tr>
<td><a href="https://codeforces.com/contest/141/problem/D">CF141D</a></td>
<td>2300</td>
<td>DP、最短路</td>
<td>---</td>
<td>从要求的结果来看，这是一个求最短路的问题，但又可以用DP去做。真正操作起来，发现真用DP做起来转移比较麻烦（涉及到往回走），所以可以考虑直接建图跑最短路算法</td>
</tr>
<tr>
<td><a href="https://codeforces.com/contest/164/problem/A">CF164A</a></td>
<td>1700</td>
<td>两遍DFS</td>
<td>---</td>
<td>图论题容易想当然，在可能有环的图上执行一个算法时，需要多造一些包含环的样例，并模拟一些不同的DFS顺序</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/102861/problem/I">CF102861I</a></td>
<td>1800</td>
<td>树形DP、乘法逆元、前后缀分解</td>
<td>---</td>
<td>正确做法是前后缀分解去维护子树的乘积，如果用乘法逆元的话，可能会遇到dp值为0的问题。我们脑子里仍然要把乘法逆元认为是除法，这样就不会忘记0没有逆元这个事实</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/105862/problem/H">CF105862H</a></td>
<td>1800</td>
<td>期望、贡献法</td>
<td>---</td>
<td>首先要发现每个数的贡献次数是一样的，只需要算某一个数的贡献次数，然后在求贡献次数时，可以考虑枚举 step，看有多少个合法的 current，current 的数量其实就是形成的循环中的位置个数（关键转化），所以变成了求每次走 step 步形成的环有多大</td>
</tr>
<tr>
<td><a href="https://codeforces.com/contest/2148/problem/F">CF2148F</a></td>
<td>1800</td>
<td>贪心、根号结论</td>
<td><a href="https://codeforces.com/blog/entry/146112">官方题解</a></td>
<td>对于一个数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，将其拆成若干个正整数相加的形式，则在一个拆分中至多能拆出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msqrt><mi>n</mi></msqrt><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\sqrt{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.05028em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">n</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 种不同的数。使用这个结论可以知道复杂度是对的</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/105387/problem/G">CF105387G</a></td>
<td>1800</td>
<td>DP、前缀和、取模易错点</td>
<td></td>
<td>题目中涉及到取模后做减法，所以最后计算出的结果有可能是负数，需要调整成正数后输出</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/104777/problem/N">CF104777N</a></td>
<td>1800</td>
<td>字典树</td>
<td></td>
<td>首先要能分析出来前缀异或和互不相同才可能有解，然后注意到由于已经互不相同了，所以不管怎么异或都是互不相同，所以选定一个数之后我们关键是验证其能不能让最大值恰好为 n - 1，这就需要 01 Trie 来做了</td>
</tr>
<tr>
<td><a href="https://codeforces.com/contest/2149/problem/E">CF2149E</a></td>
<td>1600</td>
<td>双指针、前缀和思想</td>
<td></td>
<td>这题是个前缀和套娃题，首先我们应该知道，假如不限制长度的话，我们会用双指针求不超过 k 种数的区间数，进一步，限制长度的话，如果只是限制上限，那么这个事情也是简单的，进而我们发现可以用前缀和的思想把下限的情况也解决了；然后考虑恰好 k 种，其实就是不超过 k 种减去不超过 k - 1 种的区间数</td>
</tr>
<tr>
<td><a href="https://codeforces.com/contest/1487/problem/E">CF1487E</a></td>
<td>2000</td>
<td>枚举，mex</td>
<td></td>
<td>有多个变量互相牵制且都需要枚举，需要考虑枚举哪个，才能让另外的可以少枚举或者预处理即可得到结果</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/100488/problem/I">CF100488I</a></td>
<td>1600</td>
<td>并查集、补图</td>
<td></td>
<td>首先发现这道题是说的当且仅当，也就是说不相邻的点必须有相同颜色，所以容易想到补图中同一个连通块里的点的颜色必须相同，然后用原图的边检查是否冲突即可</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/100488/problem/K">CF100488K</a></td>
<td>1800</td>
<td>反悔贪心</td>
<td></td>
<td>首先不难分析出来，前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个里面至多拿 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{i + 1}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.200664em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.855664em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 个，考虑前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个里自己能拿多少钱的，要么发现自己能多拿一个，要么发现需要和之前某个最便宜的换，换总是不会违反拿的个数约束的</td>
</tr>
<tr>
<td><a href="https://codeforces.com/problemset/problem/865/D">CF865D</a></td>
<td>2400</td>
<td>反悔贪心</td>
<td></td>
<td>反悔贪心问题中，我们想的贪心可以傻瓜得不行，因为关键在于怎么反悔，只要保证反悔之后是最优的就好了</td>
</tr>
</tbody>
</table>
<p>AtCoder：</p>
<p>其他题目：</p>
<table>
<thead>
<tr>
<th>题目链接</th>
<th>难度</th>
<th>Tag</th>
<th>题解</th>
<th>学到的东西</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://www.luogu.com.cn/problem/P5676">洛谷P5676</a></td>
<td>绿</td>
<td>强连通分量</td>
<td>---</td>
<td>边界情况判错了，当本题的有趣度是自己的兴奋度的倍数时，可以循环做本题，而不是相等，如果判错了会丢掉 40 分！另外如果没有样例提示能单点成环也算的话，可能会直接得 0 分！</td>
</tr>
<tr>
<td><a href="https://ac.nowcoder.com/acm/contest/116658/F">牛客周赛108F</a></td>
<td>2000分</td>
<td>位运算、SOSDP、超集枚举</td>
<td>---</td>
<td>一个新知识点，要求某个数所有超集的某个值，无需枚举其所有超集，只需要枚举比其多一个set位的集合即可</td>
</tr>
<tr>
<td><a href="https://www.luogu.com.cn/problem/P4832">洛谷P4832</a></td>
<td>绿</td>
<td>带偏移量的DP、滚动数组</td>
<td>---</td>
<td>复习了一下这两个东西，有段时间没遇到了</td>
</tr>
<tr>
<td><a href="https://ac.nowcoder.com/acm/contest/116945/F">牛客周赛109F</a></td>
<td>1800分</td>
<td>推式子、离散化、树状数组、离线</td>
<td>---</td>
<td>利用条件，发现要求的是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mi>i</mi></msub><mo>≤</mo><mi>min</mi><mo>⁡</mo><mo>(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>+</mo><msub><mi>k</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>−</mo><msub><mi>x</mi><mi>i</mi></msub><mo>+</mo><msub><mi>k</mi><mn>2</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">y_i \le \min(x_i + k_1, -x_i + k_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 的个数，不难想到讨论两个东西在什么情况下最小，然后就可以把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>min</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\min</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66786em;vertical-align:0em;"></span><span class="mop">min</span></span></span></span> 去掉求解了</td>
</tr>
</tbody>
</table>
<p>看到的有意思的东西：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/1945782212176909162">每次删除两个不同的数，至多删除多少次</a></li>
<li><a href="https://www.zhihu.com/question/1936769453896501072">&quot;保证数据随机&quot;到底隐含了什么</a></li>
<li><a href="https://github.com/2754LM/oj_helper">OJ helper</a>，可以查所有平台的总题量。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSP-S知识点备忘录]]></title>
        <id>https://BUAA-Wander.github.io/post/csp-s-checklist/</id>
        <link href="https://BUAA-Wander.github.io/post/csp-s-checklist/">
        </link>
        <updated>2025-08-26T08:16:06.000Z</updated>
        <content type="html"><![CDATA[<p>最近在备考 CSP-S，看到 B 站<a href="https://space.bilibili.com/443688461">某竞赛教练</a>有说到要拿省一需要补齐短板，检查自己每个知识点到底能会做什么难度的题目。考虑到自己最近一年多一直在随机刷题，虽然颇有进步，但是确实不太清楚自己每个知识点的具体掌握情况。稍微浏览了教练提供的 <a href="https://docs.qq.com/sheet/DWFh6dWVscUZQbldo?tab=bv34hm">checklist</a> 之后，意外的发现一些东西有点忘了，甚至有极个别的知识点我还不会（例如割点割边、树的重心等）。因此，我准备做一个备忘录，把自己已经忘掉的 CSP-J/S 组知识点做下总结，补齐短板，希望能够在复赛稳定打出一个满意的成绩，不要因为知识点忘了而丢分。</p>
<p>本备忘录优先记录有所遗忘的知识点，如有时间，会对重点考点的重要技巧再进行一些总结。</p>
<h2 id="时间复杂度计算">时间复杂度计算</h2>
<p>初赛里的题目主要是考主定理，对于下面的式子：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>a</mi><mi>T</mi><mo>(</mo><mfrac><mi>n</mi><mi>b</mi></mfrac><mo>)</mo><mo>+</mo><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">T(n) = aT(\frac{n}{b}) + f(n)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.7935600000000003em;vertical-align:-0.686em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">b</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span></p>
<p>当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><msup><mi>n</mi><mrow><msub><mi>log</mi><mo>⁡</mo><mi>b</mi></msub><mi>a</mi><mo>−</mo><mi>ϵ</mi></mrow></msup><mo>)</mo><mo separator="true">,</mo><mi>ϵ</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f(n) = O(n^{\log_ba - \epsilon}), \epsilon &gt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mop mtight">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.23015999999999992em;"><span style="top:-2.2341314285714287em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.26586857142857145em;"><span></span></span></span></span></span></span><span class="mspace mtight" style="margin-right:0.19516666666666668em;"></span><span class="mord mathdefault mtight">a</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">ϵ</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">ϵ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 时，有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi mathvariant="normal">Θ</mi><mo>(</mo><msup><mi>n</mi><mrow><msub><mi>log</mi><mo>⁡</mo><mi>b</mi></msub><mi>a</mi></mrow></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">T(n) = \Theta(n^{\log_ba})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mop mtight">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.23015999999999992em;"><span style="top:-2.2341314285714287em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.26586857142857145em;"><span></span></span></span></span></span></span><span class="mspace mtight" style="margin-right:0.19516666666666668em;"></span><span class="mord mathdefault mtight">a</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，例如 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mn>2</mn><mi>T</mi><mo>(</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo>)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">T(n) = 2T(\frac{n}{2}) + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.095em;vertical-align:-0.345em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，复杂度就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\Theta(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p>
<p>当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi mathvariant="normal">Ω</mi><mo>(</mo><msup><mi>n</mi><mrow><msub><mi>log</mi><mo>⁡</mo><mi>b</mi></msub><mi>a</mi><mo>+</mo><mi>ϵ</mi></mrow></msup><mo>)</mo><mo separator="true">,</mo><mi>ϵ</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f(n) = \Omega(n^{\log_ba + \epsilon}), \epsilon &gt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mord">Ω</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mop mtight">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.23015999999999992em;"><span style="top:-2.2341314285714287em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.26586857142857145em;"><span></span></span></span></span></span></span><span class="mspace mtight" style="margin-right:0.19516666666666668em;"></span><span class="mord mathdefault mtight">a</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">ϵ</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">ϵ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 时，有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi mathvariant="normal">Θ</mi><mo>(</mo><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">T(n) = \Theta(f(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，直观理解就是对分治的结果进行合并时，合并代价太大了，以至于复杂度由合并复杂度主导。</p>
<p>当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi mathvariant="normal">Θ</mi><mo>(</mo><msup><mi>n</mi><mrow><msub><mi>log</mi><mo>⁡</mo><mi>b</mi></msub><mi>a</mi></mrow></msup><msup><mi>log</mi><mo>⁡</mo><mi>k</mi></msup><mi>n</mi><mo>)</mo><mo separator="true">,</mo><mi>k</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f(n) = \Theta(n^{\log_ba}\log^kn), k \ge 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1834479999999998em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mop mtight">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.23015999999999992em;"><span style="top:-2.2341314285714287em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.26586857142857145em;"><span></span></span></span></span></span></span><span class="mspace mtight" style="margin-right:0.19516666666666668em;"></span><span class="mord mathdefault mtight">a</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9334479999999998em;"><span style="top:-3.1473400000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 时，有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi mathvariant="normal">Θ</mi><mo>(</mo><msup><mi>n</mi><mrow><msub><mi>log</mi><mo>⁡</mo><mi>b</mi></msub><mi>a</mi></mrow></msup><msup><mi>log</mi><mo>⁡</mo><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msup><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">T(n) = \Theta(n^{\log_ba} \log^{k + 1}n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1834479999999998em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mop mtight">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.23015999999999992em;"><span style="top:-2.2341314285714287em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.26586857142857145em;"><span></span></span></span></span></span></span><span class="mspace mtight" style="margin-right:0.19516666666666668em;"></span><span class="mord mathdefault mtight">a</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9334479999999998em;"><span style="top:-3.14734em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。例如 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mn>2</mn><mi>T</mi><mo>(</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo>)</mo><mo>+</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">T(n) = 2T(\frac{n}{2}) + n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.095em;vertical-align:-0.345em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>（归并排序），复杂度就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi><mo>(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\Theta(n\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。再例如，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>T</mi><mo>(</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo>)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">T(n) = T(\frac{n}{2}) + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.095em;vertical-align:-0.345em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> （二分查找），复杂度就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi><mo>(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\Theta(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p>
<h2 id="基础算法与数据结构">基础算法与数据结构</h2>
<h3 id="排序">排序</h3>
<p>快速排序的最佳实践：</p>
<pre><code class="language-cpp">void quick_sort(int l, int r) {
    if (l &gt;= r) return;

    int pivot = a[(l + r) / 2];
    int i = l - 1, j = r + 1;
    while (i &lt; j) {
        do i++; while (a[i] &lt; pivot);
        do j--; while (a[j] &gt; pivot);
        if (i &lt; j) {
            swap(a[i], a[j]);
        }
    }
    
    quick_sort(l, j);
    quick_sort(j + 1, r);
}
</code></pre>
<p>划分区间时，左边的区间中都是 <code>&lt;= pivot</code> 的数，右边的区间中都是 <code>&gt;= pivot</code> 的数，这个隐含的意思是等于 <code>pivot</code> 的数在左右两个区间都有。</p>
<p>下面证明按照 <code>[l, j]</code> 和 <code>[j + 1, r]</code> 分区不会导致死递归。</p>
<p>本质上，我们需要证明每次递归调用的子数组范围 <code>[l, j]</code> 和 <code>[j + 1, r]</code> 都严格小于原数组 <code>[l, r]</code>（即至少减少一个元素），或者证明两个数组都不为空就好了。</p>
<p>首先，左半边区间 <code>[l, j]</code> 一定不会为空，因为最差的情况就是 <code>l == j</code>。下面只要证明右子数组不为空即可。事实上，<code>i</code> 会先移动到 <code>pivot</code> 或者更左边的第一个 <code>&gt;= pivot</code> 的数字上，<code>j</code> 会先移动到 <code>pivot</code> 或者更右边的某个 <code>&lt;= pivot</code> 的数字上，这又分两种情况：</p>
<ul>
<li>倘若都恰好是 <code>pivot</code>，由于 <code>(l + r) / 2 &lt; r</code>，所以 <code>j &lt; r</code> 一定成立，所以 <code>j + 1 &lt;= r</code> 一定成立，所以 <code>[j + 1, r]</code> 也不为空</li>
<li>倘若至少有一个不是 <code>pivot</code>，说明这个时候一定有 <code>i &lt; j</code>，必然会发生一次交换，然后再分别至少执行一次 <code>i++, j--</code>，这个时候 <code>j</code> 一定移动得 <code>&lt; r</code> 了，所以 <code>j + 1 &lt;= r</code> 一定成立。</li>
</ul>
<p>综上，左子数组和右子数组都不为空，都是原数组严格减小后的结果，所以不会死递归。</p>
<p>代码模板记忆：只要记得代码中全是严格大于和小于号，并记住是以 <code>j</code> 为分割点进行数组划分即可。</p>
<p>以上内容总结自 AcWing 算法基础课。</p>
<h3 id="前中后缀表达式">前/中/后缀表达式</h3>
<h3 id="差分">差分</h3>
<p>主要是二维差分记忆有点模糊。</p>
<p>如何得到差分矩阵？</p>
<pre><code>d[i][j] = a[i][j] - a[i - 1][j] - a[i][j - 1] + a[i - 1][j - 1]
</code></pre>
<p>这个结果并不是很直观。</p>
<p>如何在差分矩阵上做修改？</p>
<p>画一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mo>×</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">3 \times 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 的矩阵，看如何把左上角 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>×</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2 \times 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 的矩阵通过差分变成全 1。</p>
<p>需要：</p>
<pre><code class="language-cpp">d[1][1] += 1;
d[1][3] -= 1;
d[3][1] -= 1;
d[3][3] += 1;
</code></pre>
<p>所以，如果要把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>1</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(x_1, y_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(x_2, y_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的矩阵都加上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">val</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>，需要：</p>
<pre><code class="language-cpp">d[x_1][y_1] += val;
d[x_1][y_2 + 1] -= val;
d[x_2 + 1][y_1] -= val;
d[x_2 + 1][y_2 + 1] += val;
</code></pre>
<p>关于区间加等差数列，笔者有点过于翡透了，推了一段时间公式并没有推出来想要的结果。事实上，在考场上我们也可能会遇到类似的情况。倘若我们真的忘了区间加等差数列的结论了，可以使用如下代码帮我们进行回忆：</p>
<pre><code class="language-cpp">int a[10], b[10], c[10];

void meibao() {
    int s = 3, d = 4;
    for (int i = 2; i &lt;= 6; i++) {
        a[i] += s + (i - 2) * d;
    }

    for (int i = 1; i &lt; 10; i++) {
        printf(&quot;%3d &quot;, a[i]);
    }

    printf(&quot;\n&quot;);

    for (int i = 1; i &lt; 10; i++) {
        b[i] = a[i] - a[i - 1];
        printf(&quot;%3d &quot;, b[i]);
    }

    printf(&quot;\n&quot;);

    for (int i = 1; i &lt; 10; i++) {
        c[i] = b[i] - b[i - 1];
        printf(&quot;%3d &quot;, c[i]);
    }
}
</code></pre>
<p>输出结果为：</p>
<pre><code>  0   3   7  11  15  19   0   0   0 
  0   3   4   4   4   4 -19   0   0 
  0   3   1   0   0   0 -23  19   0 
</code></pre>
<p>通过观察，我们发现一阶差分上规律比较明显，先在 <code>l</code> 处加一个首项，再在 <code>[l + 1, r]</code> 上加公差，最后在 <code>r + 1</code> 上减掉最后一项。为了完成这三个对一阶差分的区间加操作，需要在二阶差分上做 6 次单点修改。</p>
<p>于是，我们归纳出在 <code>[l, r]</code> 上，加一个首项为 <code>s</code>，公差为 <code>d</code> 的等差数列怎么做：</p>
<pre><code class="language-cpp">void add(int l, int r, int s, int d) {
    // t 是最后一项
    int t = s + (r - l) * d;
    c[l] += s;
    c[l + 1] += d - s;
    c[r + 1] -= (t + d);
    c[r + 2] += t;
}
</code></pre>
<p>在考场上，我们写出这个之后，可以再写一个对拍去验证一下，这样就重新发明出了区间加等差数列公式。</p>
<p>事实上，在一阶差分数组上的规律更明显，但是可能得用线段树去维护一阶差分。</p>
<p>由于 NOI 特别把差分这个知识点在新大纲中提出来了，所以在这里做了比较多的总结。</p>
<h3 id="二分查找">二分查找</h3>
<p>虽然我们已经会了下面这个模板：</p>
<pre><code class="language-cpp">while (l + 1 &lt; r) {
    mid = (l + r) &gt;&gt; 1;
    if (check(mid)) {
        l = mid;
    } else {
        r = mid;
    }
}
// 单独判断 l 和 r
</code></pre>
<p>但是有些时候会有人问自己标准二分怎么写，或者直接给你来个程序填空或者捉虫，这个时候就还是得会标准二分。</p>
<p>二分要注意的地方主要有两个：</p>
<ol>
<li>如何不丢/错过解</li>
<li>怎么样能不死递归</li>
</ol>
<p>思考如何避免死递归时，不妨直接考虑最初始的数组长度就是 2，这是最容易死递归的情况。</p>
<p>以手写 <code>lower_bound</code> 为例子，假设我们想找 <code>&gt;= 1</code> 的最小的数的位置，数组是 <code>1 2</code>，则可以这样写：</p>
<pre><code class="language-cpp">while (l &lt; r) {
    mid = (l + r) &gt;&gt; 1;
    if (a[mid] &gt;= 1) {
        r = mid;
    } else {
        l = mid + 1;
    }
}
return a[l];
</code></pre>
<p>为什么这样不会死递归？首先我们应该注意到，由于限制了 <code>l != r</code>，且右移是下取整的（除法是向 0 取整，负数时会有问题），所以一定有 <code>((l + r) &gt;&gt; 1) != r</code>。因此，当 <code>a[mid]</code> 符合题意时，我们令 <code>r = mid</code> 即可，无需减去 1，减掉了会漏解。当 <code>a[mid]</code> 不符合题意时，说明 <code>mid</code> 没用，所以 <code>l = mid + 1</code> 即可。</p>
<p>类似的，还有一个东西叫做 <code>mid = (l + r + 1) &gt;&gt; 1</code>，这个东西是上取整的，所以在 <code>l &lt; r</code> 时 <code>mid != l</code>。如果符合题意时要求区间左端点移动，则可以 <code>l = mid</code>，不符合题意时 <code>r = mid - 1</code>。</p>
<p>以上内容总结自算法竞赛进阶指南。</p>
<h3 id="单调栈">单调栈</h3>
<p>解决各种问题</p>
<h3 id="离散化">离散化</h3>
<p>主要是 <code>map</code> 的大值域离散化</p>
<h2 id="图论">图论</h2>
<h3 id="链式前向星">链式前向星</h3>
<p>先来一份代码：</p>
<pre><code class="language-cpp">// 数据结构
LL h[N], e[M], ne[M], w[M], idx;

// 加边函数
void add(int a, int b, LL c) {
    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx++;
}

// 初始化邻接表
memset(h, -1, sizeof h);
idx = 0;
for (int i = 1; i &lt;= m; i++) {
    LL a, b, c;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
    add(a, b, c);
}

// 遍历 ver 结点的所有邻边，并做 dijkstra 的松弛操作
for (int i = h[ver]; i &gt;= 0; i = ne[i]) {
    int v = e[i];
    if (d[v] &gt; d[ver] + w[i]) {
        d[v] = d[ver] + w[i];
        q.push({d[v], v});
    } 
}
</code></pre>
<p>其中：</p>
<ul>
<li><code>h[i]</code> 存储的是 <code>i</code> 结点的第一条边的编号，注意所有 <code>i</code> 结点的邻边组成一条链表，所以 <code>h[i]</code> 相当于链表入口，一般初始化为 <code>-1</code>，表示链表为空。忘记初始化会 TLE，因为边的编号一直都是 0，跳不出循环。</li>
<li><code>e[id]</code> 指的是编号为 <code>id</code> 的这条边指向的结点。</li>
<li><code>ne[id]</code> 指的是编号为 <code>id</code> 的这条边所在链表的下一条边的 <code>id</code>。</li>
<li><code>add(a, b)</code> 是加边函数，其逻辑是先把指向的结点 <code>b</code> 存到 <code>e[idx]</code> 中，再考虑创建一个新的链表结点，并将其头插到当前链表中作为新的头（<code>ne[idx] = h[a], h[a] = idx++</code>）</li>
</ul>
<h3 id="堆">堆</h3>
<h4 id="二叉堆手写">二叉堆手写</h4>
<h4 id="对顶堆">对顶堆</h4>
<h4 id="反悔贪心">反悔贪心</h4>
<h3 id="带权并查集">带权并查集</h3>
<h3 id="最小环">最小环</h3>
<h3 id="次短路">次短路</h3>
<h3 id="强连通分量">强连通分量</h3>
<p>特别注意，强连通分量并不一定是环，其可能是多个环，所以做题分析时要想清楚到底是要找环还是找强连通分量。</p>
<p>首先看一下 Tarjan 算法。</p>
<p>使用 Tarjan 算法求强连通分量时，我们想的是对于每个点 <code>u</code>，维护两个时间 <code>dfn[u]</code> 和 <code>low[u]</code>。其中 <code>dfn[u]</code> 为 <code>u</code> 被第一次访问时的 dfs 时间戳，也就是 dfs 序号，<code>low[u]</code> 表示通过 <code>u</code> 能够走到的点里最小的 <code>dfn</code> 值，其初始化为 <code>low[u] = dfn[u]</code>。</p>
<p>这里对 <code>low[u]</code> 做详细的说明，其实其包含两种情况：</p>
<ul>
<li>从 <code>u</code> 可以走到一个之前从来没走过的邻点 <code>v</code>，则显然 <code>low[v]</code> 是可以用来更新 <code>low[u]</code> 的。</li>
<li>从 <code>u</code> 走到一个已经走过的邻点 <code>v</code>，这样又可以分两种情况：
<ul>
<li><code>v</code> 是在结点访问栈里面的，则说明我们往回走到了 <code>u</code> 的祖先 <code>v</code>，成了一个环，当然也可以用 <code>low[v]</code> 更新 <code>low[u]</code>。</li>
<li>（<strong>最难理解的一种情况</strong>）<code>v</code> 被访问过，但是现在不在结点访问栈里面，那么 <code>u</code> 和 <code>v</code> 一定不在同一个强连通分量内。我们反证一下上面这个事情，假如 <code>u</code> 和 <code>v</code> 在同一个强连通分量内，则必然存在一条路径能从 <code>v</code> 走到 <code>u</code>。那么在第一次访问到 <code>v</code> 的时候，假如其到 <code>u</code> 的那条路上的点都没被访问过，则 <code>v</code> 可以一直 DFS 到 <code>u</code>，这时候是 <code>v</code> 在栈中，和不在栈中的条件矛盾；假如其到 <code>u</code> 的那条路上的点有的已经被访问过了，那么 <code>u</code> 一定被更早的点访问过了，这会推出 <code>u</code> 比 <code>v</code> 更早被访问，和条件矛盾。综上，这种情况下 <code>u</code> 和 <code>v</code> 一定不在同一个强连通分量内，无需更新 <code>low[u]</code>。</li>
</ul>
</li>
</ul>
<p>最后弹出强连通分量时，我们要先找到 <code>dfn[u] = low[u]</code> 的点，然后从栈中一直弹，直到弹到这个点，则这部分都是属于 <code>u</code> 为“根”的强连通分量。对于 <code>dfn[u] != low[u]</code> 的点，我们就不能启动弹栈这个操作，因为其不是强连通分量的“根”。</p>
<p><a href="https://www.luogu.com.cn/problem/P2863">模板题</a></p>
<p>代码模板：</p>
<pre><code class="language-cpp">int n, m, timestamp = 0, dfn[N], low[N];
bool vis[N], instk[N];
vector&lt;vector&lt;int&gt;&gt; e(N);
vector&lt;vector&lt;int&gt;&gt; scc;
vector&lt;int&gt; stk;

void tarjan(int u) {
    vis[u] = true;
    stk.push_back(u);
    instk[u] = true;
    dfn[u] = ++timestamp;
    low[u] = dfn[u];

    for (auto v : e[u]) {
        if (!vis[v]) {
            tarjan(v);
            low[u] = min(low[u], low[v]);
        } else if (instk[v]) {
            low[u] = min(low[u], low[v]);
        }
    }

    if (dfn[u] == low[u]) {
        vector&lt;int&gt; s;
        while (true) {
            int v = stk.back();
            stk.pop_back();
            s.push_back(v);
            instk[v] = false;
            if (v == u) {
                break;
            }
        }
        scc.push_back(s);
    } 
}

void meibao() {
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 1; i &lt;= m; i++) {
        int u, v;
        cin &gt;&gt; u &gt;&gt; v;
        e[u].push_back(v);
    }

    for (int i = 1; i &lt;= n; i++) {
        if (!vis[i]) {
            tarjan(i);
        }
    }

    int res = 0;
    for (int i = 0; i &lt; scc.size(); i++) {
        if (scc[i].size() &gt; 1) {
            res++;
        }
    }
    cout &lt;&lt; res &lt;&lt; &quot;\n&quot;;
}
</code></pre>
<h3 id="双连通分量">双连通分量</h3>
<h3 id="割点与割边">割点与割边</h3>
<h3 id="二分图最大匹配">二分图最大匹配</h3>
<h3 id="spfa">SPFA</h3>
<h3 id="欧拉图">欧拉图</h3>
<p>即能否一笔画的图，无向图的话需要每个点的度数都是偶数，有向图的话需要入度 = 出度。</p>
<h2 id="dp">DP</h2>
<h3 id="树形-dp">树形 DP</h3>
<h3 id="重心">重心</h3>
<h3 id="树上背包">树上背包</h3>
<h3 id="数位-dp">数位 DP</h3>
<h2 id="数据结构">数据结构</h2>
<h3 id="表达式树">表达式树</h3>
<h3 id="树状数组基本原理">树状数组基本原理</h3>
<p>lowbit，下标的结构</p>
<h3 id="线段树扩展操作">线段树扩展操作</h3>
<h3 id="动态开点线段树">动态开点线段树</h3>
<h3 id="扫描线">扫描线</h3>
<h2 id="数学">数学</h2>
<h3 id="约数函数">约数函数</h3>
<p>我们记一个数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的约数个数为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">d(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">d(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 称为约数函数。显然，一个数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的约数个数不会超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><msqrt><mi>n</mi></msqrt><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2\sqrt{n} + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.23972em;"></span><span class="mord">2</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">n</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，但这是一个很粗糙的估计，这种粗糙的估计会让我们对一些算法的复杂度做出错误的估计。</p>
<p>在做题时，真正有用的是我们要知道 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 在一定范围内的时候，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">d(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 最大可能的值。比如：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">n \le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>，则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">d(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 最大只有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>128</mn></mrow><annotation encoding="application/x-tex">128</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">8</span></span></span></span>，我们可以打表打出来发现是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mn>83160</mn></mrow><annotation encoding="application/x-tex">n = 83160</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span><span class="mord">3</span><span class="mord">1</span><span class="mord">6</span><span class="mord">0</span></span></span></span> 时取到，显然 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>12</mn><msup><mn>8</mn><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">128^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord"><span class="mord">8</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> 比 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 还小不少。</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>7</mn></msup></mrow><annotation encoding="application/x-tex">n \le 10^7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span>，则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">d(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 最大只有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>448</mn></mrow><annotation encoding="application/x-tex">448</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">4</span><span class="mord">8</span></span></span></span>，在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mn>8648640</mn></mrow><annotation encoding="application/x-tex">n = 8648640</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span><span class="mord">6</span><span class="mord">4</span><span class="mord">8</span><span class="mord">6</span><span class="mord">4</span><span class="mord">0</span></span></span></span> 时取到。</li>
</ul>
<p>假如 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>7</mn></msup></mrow><annotation encoding="application/x-tex">n \le 10^7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span>，做题时我们可以粗糙地将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">d(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 认为是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>500</mn></mrow><annotation encoding="application/x-tex">500</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span></span></span></span>，用这个数去估计计算量。</p>
<h3 id="乘法逆元">乘法逆元</h3>
<h4 id="使用之前特别关注是否存在">使用之前特别关注是否存在</h4>
<p>怎么求倒是小问题，一般来说直接用费马小定理 + 快速幂搞定了。最关键的其实应该是“怎么求”之前的东西，即先判断一道可以用逆元求解的问题，会不会出现逆元不存在的情况。</p>
<p>我们先回忆一下逆元的定义，假如 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>x</mi><mo>≡</mo><mn>1</mn><mo>(</mo><mtext>mod</mtext><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">ax \equiv 1(\text{mod}m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46375em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mopen">(</span><span class="mord text"><span class="mord">mod</span></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>，则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 的乘法逆元。对于某个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>，为了使其乘法逆元 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 存在，需要这个同余方程有解，转化成不定方程就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>m</mi><mi>y</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">ax + my = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 有解，这需要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>gcd</mi><mo>⁡</mo><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>m</mi><mo>)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\gcd(a, m) = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span style="margin-right:0.01389em;">g</span>cd</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，这就是乘法逆元存在的充要条件。</p>
<p><strong>一般来说</strong>，题目中给的模数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 是<strong>素数</strong>，这个时候相当于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 只要不是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 的倍数就好了。特别地，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 的倍数，所以这个时候不存在乘法逆元。什么时候会出现倍数的情况呢？假如有一个要求乘法逆元的数有可能比 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 大，且这个数的来历可能是一堆数加减乘除得到的，则不排除这个数是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 的倍数的可能。但我们用乘法逆元最多的情况是求组合数，组合数中是对一阶乘求逆元，而只要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>&lt;</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n &lt; m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>，就必然有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>gcd</mi><mo>⁡</mo><mo>(</mo><mi>n</mi><mo>!</mo><mo separator="true">,</mo><mi>m</mi><mo>)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\gcd(n!, m) = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span style="margin-right:0.01389em;">g</span>cd</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">!</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，因为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 中都没有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 这个素因子。</p>
<p>有时候给的模数为合数，或者可能要输入模数，这时候就更要格外小心逆元不存在的情况了。</p>
<p>事实上，我们应该把乘法逆元仍然按照除法去思考，除法是不能除 0 的，所以也不能求 0 的乘法逆元，就算算出了一个所谓的“乘法逆元”，也是错误的，这在除法中本该报出除 0 异常，但使用乘法逆元就会把这个本该抛异常导致程序崩溃的错误，变成一个<strong>悄悄的可以继续执行的错误</strong>，这种问题就会很难排查。</p>
<h4 id="一个不存在的例子">一个不存在的例子</h4>
<p>有一个比较典型的容易犯错的例子，给一个数组 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>，我们想求去掉里面某个数之后，剩下的数字的乘积，则我们很容易想到两种方案：</p>
<ul>
<li>前后缀分解，直接用剩下的前缀和后缀的乘积相乘即可。</li>
<li>预处理所有数的乘积，每次询问除去去掉的那个数（即乘以逆元）。</li>
</ul>
<p>对于第一种方法，完全没用到逆元，所以无需担心。对于第二种方法，不妨设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>=</mo><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">a = [1, 2, 0, 3, 4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mclose">]</span></span></span></span>，假如去掉的是 0，由于最开始预处理所有的数的乘积就是 0，所以按照这种做法算出来剩下的数的乘积还是 0，但实际上应该是 24，这就错了。</p>
<h3 id="exgcd">exgcd</h3>
<p>主要是分析如何求通解。</p>
<p>假设现在已经得到了一组 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi><mo>=</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">ax + by = c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span> 的特解 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>x</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>0</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(x_0, y_0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，则考虑 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 最少变化多少，还能使得解出来的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 是整数。</p>
<p>不妨设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 最少变化 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">d_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，能够让 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 还是整数，且 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 的变化是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">d_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，则有：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi><mo>=</mo><mi>a</mi><mo>(</mo><mi>x</mi><mo>+</mo><msub><mi>d</mi><mn>1</mn></msub><mo>)</mo><mo>+</mo><mi>b</mi><mo>(</mo><mi>y</mi><mo>−</mo><msub><mi>d</mi><mn>2</mn></msub><mo>)</mo><mo>=</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">ax + by = a(x + d_1) + b(y - d_2) = c
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span></span></p>
<p>也就是说</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><msub><mi>d</mi><mn>1</mn></msub><mo>=</mo><mi>b</mi><msub><mi>d</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">ad_1 = bd_2
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">b</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>所以有</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mn>2</mn></msub><mo>=</mo><mfrac><mrow><mi>a</mi><msub><mi>d</mi><mn>1</mn></msub></mrow><mi>b</mi></mfrac></mrow><annotation encoding="application/x-tex">d_2 = \frac{ad_1}{b}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">b</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>我们想求最小的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">d_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，使得 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">d_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 也是整数，则要求 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><msub><mi>d</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">ad_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 的倍数，而 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><msub><mi>d</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">ad_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 显然是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 的倍数，所以要：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><msub><mi>d</mi><mn>1</mn></msub><mo>=</mo><mtext>lcm</mtext><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">ad_1 = \text{lcm}(a, b)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">lcm</span></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></span></p>
<p>也就是：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mn>1</mn></msub><mo>=</mo><mfrac><mrow><mtext>lcm</mtext><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo></mrow><mi>a</mi></mfrac></mrow><annotation encoding="application/x-tex">d_1 = \frac{\text{lcm}(a, b)}{a}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.113em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">lcm</span></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的通解就是</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><msub><mi>x</mi><mn>0</mn></msub><mo>+</mo><mi>k</mi><msub><mi>d</mi><mn>1</mn></msub><mo separator="true">,</mo><mi>k</mi><mo>∈</mo><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">x = x_0 + kd_1, k \in \Z
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">Z</span></span></span></span></span></span></p>
<p>对于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 可以类似地得到结果。</p>
<h3 id="扩展中国剩余定理excrt">扩展中国剩余定理（excrt）</h3>
<p>我们直接跳过普通版中国剩余定理，因为其功能完全是扩展版的子集，且算法的逻辑很不一样。</p>
<p>扩展中国剩余定理的核心在于不断将现有的两个同余方程合并成一个，直到只剩下一个同余方程，此时我们也就解出了同余方程组的通解。</p>
<p>我们分析如何对如下两个方程组进行合并：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">{</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>x</mi><mo>≡</mo><msub><mi>r</mi><mn>1</mn></msub><mo>(</mo><mtext>mod </mtext><msub><mi>m</mi><mn>1</mn></msub><mo>)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>x</mi><mo>≡</mo><msub><mi>r</mi><mn>2</mn></msub><mo>(</mo><mtext>mod </mtext><msub><mi>m</mi><mn>2</mn></msub><mo>)</mo></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{cases}
x \equiv r_1 (\text{mod }m_1)\\
x \equiv r_2 (\text{mod }m_2)
\end{cases}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord text"><span class="mord">mod </span></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord text"><span class="mord">mod </span></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>先将其转化为带余除法的形式：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">{</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>x</mi><mo>=</mo><msub><mi>k</mi><mn>1</mn></msub><msub><mi>m</mi><mn>1</mn></msub><mo>+</mo><msub><mi>r</mi><mn>1</mn></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>x</mi><mo>=</mo><msub><mi>k</mi><mn>2</mn></msub><msub><mi>m</mi><mn>2</mn></msub><mo>+</mo><msub><mi>r</mi><mn>2</mn></msub></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{cases}
x = k_1m_1 + r_1\\
x = k_2m_2 + r_2
\end{cases}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>进而有：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mn>1</mn></msub><msub><mi>m</mi><mn>1</mn></msub><mo>−</mo><msub><mi>k</mi><mn>2</mn></msub><msub><mi>m</mi><mn>2</mn></msub><mo>=</mo><msub><mi>r</mi><mn>2</mn></msub><mo>−</mo><msub><mi>r</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">k_1m_1 - k_2m_2 = r_2 - r_1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>这是关于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">k_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">k_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的二元一次方程，其他量都是已知的，所以我们可以使用 exgcd 先求出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">k_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的一个特解 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">k_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，并得到通解为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mn>1</mn></msub><mo>=</mo><msub><mi>k</mi><mn>0</mn></msub><mo>+</mo><mi>t</mi><mo>×</mo><mfrac><mrow><mtext>lcm</mtext><mo>(</mo><msub><mi>m</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>m</mi><mn>2</mn></msub><mo>)</mo></mrow><msub><mi>m</mi><mn>1</mn></msub></mfrac></mrow><annotation encoding="application/x-tex">k_1 = k_0 + t\times \frac{\text{lcm}(m_1, m_2)}{m_1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69841em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.4550999999999998em;vertical-align:-0.44509999999999994em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">lcm</span></span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.44509999999999994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>。</p>
<p>我们把这个通解代入回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><msub><mi>k</mi><mn>1</mn></msub><msub><mi>m</mi><mn>1</mn></msub><mo>+</mo><msub><mi>r</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x = k_1m_1 + r_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，得到：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mo>(</mo><msub><mi>k</mi><mn>0</mn></msub><mo>+</mo><mi>t</mi><mo>×</mo><mfrac><mrow><mtext>lcm</mtext><mo>(</mo><msub><mi>m</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>m</mi><mn>2</mn></msub><mo>)</mo></mrow><msub><mi>m</mi><mn>1</mn></msub></mfrac><mo>)</mo><mo>×</mo><msub><mi>m</mi><mn>1</mn></msub><mo>+</mo><msub><mi>r</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x = (k_0 + t\times \frac{\text{lcm}(m_1, m_2)}{m_1})\times m_1 + r_1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69841em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.263em;vertical-align:-0.8360000000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">lcm</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>注意到这个式子中，只有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span> 是未知的，其他的都是已知的，进一步整理有：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mi>t</mi><mo>×</mo><mtext>lcm</mtext><mo>(</mo><msub><mi>m</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>m</mi><mn>2</mn></msub><mo>)</mo><mo>+</mo><msub><mi>k</mi><mn>0</mn></msub><msub><mi>m</mi><mn>1</mn></msub><mo>+</mo><msub><mi>r</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x = t\times \text{lcm}(m_1, m_2) + k_0m_1 + r_1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69841em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">lcm</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>这个方程和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><msub><mi>k</mi><mn>1</mn></msub><msub><mi>m</mi><mn>1</mn></msub><mo>+</mo><msub><mi>r</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x = k_1m_1 + r_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 形式很像，这意味着我们把最开始的两个方程，合并成了一个形式很像的方程。</p>
<p>落实到代码上，我们的合并方程函数相当于接收 4 个参数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>r</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>m</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>r</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>m</mi><mn>2</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(r_1, m_1, r_2, m_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，即接收两个方程，最终返回两个参数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>r</mi><mo separator="true">,</mo><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(r, m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>，即一个新的方程，其中：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">{</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>r</mi><mo>=</mo><msub><mi>k</mi><mn>0</mn></msub><msub><mi>m</mi><mn>1</mn></msub><mo>+</mo><msub><mi>r</mi><mn>1</mn></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>m</mi><mo>=</mo><mtext>lcm</mtext><mo>(</mo><msub><mi>m</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>m</mi><mn>2</mn></msub><mo>)</mo></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{cases}
r = k_0m_1 + r_1\\
m = \text{lcm}(m_1, m_2)
\end{cases}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord text"><span class="mord">lcm</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">k_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 需要使用 exgcd 计算，这个地方可能会触发无解，无解可以直接返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(0, 0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span>。</p>
<p>把所有方程合并后，对于最终返回的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>r</mi><mo separator="true">,</mo><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(r, m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>，事实上就是方程：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>≡</mo><mi>r</mi><mo>(</mo><mtext>mod </mtext><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">x \equiv r(\text{mod }m)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46375em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord text"><span class="mord">mod </span></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></span></p>
<p>所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的最小正整数解就是：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo>=</mo><mo>(</mo><mi>r</mi><mtext> mod </mtext><mi>m</mi><mo>+</mo><mi>m</mi><mo>)</mo><mtext> mod </mtext><mi>m</mi></mrow><annotation encoding="application/x-tex">x_{min} = (r \text{ mod }m + m)\text{ mod }m
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord text"><span class="mord"> mod </span></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mord text"><span class="mord"> mod </span></span><span class="mord mathdefault">m</span></span></span></span></span></p>
<p>代码模板：</p>
<pre><code class="language-python">import sys

input = lambda: sys.stdin.readline().rstrip()

n = int(input())
rs = list(map(int, input().split()))
ms = list(map(int, input().split()))

def exgcd(a, b):
    if b == 0:
        return a, 1, 0

    g, xx, yy = exgcd(b, a % b)
    t = xx
    x = yy
    y = t - (a // b) * x
    return g, x, y

def gcd(a, b):
    if b == 0:
        return a
    return gcd(b, a % b)

def lcm(a, b):
    return a // gcd(a, b) * b

def combine_equation(r1, m1, r2, m2):
    g, x, y = exgcd(m1, m2)
    if (r2 - r1) % g != 0:
        return (0, 0)

    k0 = x * (r2 - r1) // g
    return (k0 * m1 + r1, lcm(m1, m2))

res = (rs[0], ms[0])
for i in range(1, n):
    res = combine_equation(res[0], res[1], rs[i], ms[i])

if res[0] == 0 and res[1] == 0:
    print(&quot;-1&quot;)
else:
    r, m = res[0], res[1]
    print((r % m + m) % m)
</code></pre>
<p>为什么这里给出的是 python 模板呢？因为这个算法是有可能出现最终结果不爆 <code>long long</code>，但中间过程爆 <code>long long</code> 的。要想彻底避免这种情况，应该使用龟速乘，但是我有点懒得写，所以直接 python 了。</p>
<h3 id="线性筛求积性函数">线性筛求积性函数</h3>
<h3 id="卡特兰数">卡特兰数</h3>
<h3 id="斯特林数">斯特林数</h3>
<h2 id="字符串">字符串</h2>
<h3 id="manacher">Manacher</h3>
<pre><code class="language-cpp">// s 长度为 n，则 N 至少是 2 * n + 3
const int N = 1e7 + 10;

struct Manacher {
    string t;
    
    /*
    改造后字符串的以 i 为中心的最长回文串的半径
    例如 aba 的半径是 2
    half_len[i] - 1 恰好就是原串中以 i 为中心的回文串的最长长度
    */
    int half_len[N];

    /*
    原串中的 [l, r] 串对应改造串中的 [2 * l + 2, 2 * r + 2]
    对应改造串的中心为 l + r + 2
    half_len[l + r + 2] - 1 &gt;= r - l + 1，说明是回文串
    */
    bool is_palindrome(int l, int r) {
        int mid = l + r + 2;
        return half_len[mid] &gt; r - l + 1; 
    }

    void init(string s) {
        t = &quot;^&quot;;
        for (auto ch : s) {
            t += &quot;#&quot;;
            t += ch;
        }
        t += &quot;#$&quot;;
        
        int n = t.size();
        for (int i = 0; i &lt; n; i++) {
            half_len[i] = 0;
        }

        half_len[1] = 1;
        /*
        box_m: 目前能造成 box_r 最大的回文中心
        box_r: 回文串窗口最右的位置 + 1
        */
        int box_m = 1, box_r = 2;
        for (int i = 2; i &lt; n - 1; i++) {
            int hl = 1;
            /*
            box_m * 2 - i: i 相对于 box_m 的对称位置
            box_r - i: 到达 box_r 以及更右边的部分还没遍历过，不知道是否相等
            */
            if (i &lt; box_r) {
                hl = min(half_len[box_m * 2 - i], box_r - i);
            }
            while (t[i + hl] == t[i - hl]) {
                hl++;
                box_m = i;
                box_r = i + hl;
            }
            half_len[i] = hl;
        }
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用Python打算法竞赛的小技巧（持续更新）]]></title>
        <id>https://BUAA-Wander.github.io/post/python-in-competitive-programming/</id>
        <link href="https://BUAA-Wander.github.io/post/python-in-competitive-programming/">
        </link>
        <updated>2025-08-20T08:30:34.000Z</updated>
        <content type="html"><![CDATA[<p>使用 Python 打算法竞赛似乎一直以来不被看好，原因主要是 Python 本身的运行效率不如 C++（尤其是只提供 CPython 时），且容易在一些好用的 API 或包的诱惑下写出<strong>大常数</strong>代码，在算法竞赛这个寸时寸金的领域稍有不慎就会 TLE。有些题可能 C++ 放过了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 的做法，但 Python 必须写 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 做法才能过。随着时代的发展，编程的普及，越来越多的朋友使用 Python 写算法题，然后就不得不直面 Python 慢的问题。在这个过程中，大家探索出了很多可以让 Python 跑得更快的实现技巧，Python 逐渐地在一些题型上有了一战之力，在蓝桥杯等比赛中甚至也出现了只能使用 Python 的组别。</p>
<p>本文主要介绍 Python 在做算法题时如何减小 Python 代码的常数（因为讲基本用法的文章网上已经有很多了），从而有可能通过更多的题目。假如比赛环境中支持多种语言，但 Python 并没有提供 PyPy 的话，最好还是别用 Python 了，老老实实用 C++ 吧。</p>
<h2 id="输入输出">输入输出</h2>
<h3 id="输入">输入</h3>
<p>一般情况下，使用 <code>input()</code> 函数就可以了，常见的输入模式：</p>
<pre><code class="language-python"># 单个数读入
n = int(input())
# 同行读入若干个数
n, k = map(int, input().split())
# 同行读入一个数组
a = list(map(int, input().split()))
# 同行读入一个数组，并且强行以 1 作为起始下标（如果你更习惯 1 作为起始下标）
a = [0] + list(map(int, input().split()))
</code></pre>
<p>但是，在需要大量输入数据的题目中，<code>input</code> 会处理内置的输入缓冲（包括提示符、换行处理等），直接使用 <code>input()</code> 函数就会 TLE 了，这个时候我们需要加这样一行代码：</p>
<pre><code class="language-python">input = lambda: sys.stdin.readline().strip()
</code></pre>
<p>加上它之后，后边的读入代码完全不用变。</p>
<p><code>sys.stdin.readline()</code> 更快，因为它直接使用系统级输入读取，但是保留了换行符，需要 <code>strip()</code> 去掉。</p>
<h3 id="输出">输出</h3>
<p>主要是使用 <code>print()</code> 函数，但是每调用一次 <code>print()</code> 函数就是一次 I/O 操作，I/O 操作过多会导致速度变慢。</p>
<p>我们考虑以下代码：</p>
<pre><code class="language-python">n = int(4e6)

for i in range(1, n + 1):
    print(i)
</code></pre>
<p>在 Codeforces custom invocation 中，使用 PyPy 3.10 进行测试，其运行了 687ms，多次运行均差不多是这些。</p>
<p>如果我们把所有的输出塞到列表里，最后统一输出：</p>
<pre><code class="language-python">n = int(4e6)
res = []
for i in range(1, n + 1):
    res.append(i)
print('\n'.join(map(str, res)))
</code></pre>
<p>需要 468ms，多次测试均差不多是这些。</p>
<p>上面只是一个简单的例子。事实上，在其他的需要大量输出的场景下，把输出最后统一进行总是会快一些。因此，在<strong>内存允许</strong>的情况下，可以把数据结构题或者多测题的输出攒起来，最后调用一次 <code>print()</code> 函数一起输出，能够提升一些速度。</p>
<h2 id="排序">排序</h2>
<p>对于一般的整数数组，我们可以直接使用 <code>nums.sort()</code> 进行排序。</p>
<p>有时候我们需要对一些复杂对象的列表进行排序，这个时候我们通过定义比较函数，使用 <code>cmp_to_key</code> 将比较函数转化为 <code>key</code> 之后进行排序即可。</p>
<p>从实践上来说，通过指定 <code>key</code> 直接对复杂对象列表排序会带来很多拷贝的开销，导致速度变慢很多。</p>
<p>这时，我们考虑另一个思路：我们初始化一个下标列表 <code>[1, n]</code>，然后对下标列表进行排序，排序的 <code>key</code> 中使用了复杂对象列表中的数据。这样之后，我们会得到一个下标列表，按照这个列表从左往右遍历，这些下标对应的复杂对象列表中的数据就是排序后的顺序。</p>
<p>看一份代码理解一下吧。这里是把元组 <code>(x, y)</code> 按照 x 从小到大排序，y 的顺序不关心，使用对下标排序的方案实现：</p>
<pre><code class="language-python">m = int(input())
xs = []
ys = []
for i in range(m):
    x, y = map(int, input().split())
    xs.append(x)
    ys.append(y)
 
order = [i for i in range(m)]
order = sorted(order, key=lambda i: xs[i])
</code></pre>
<p>由于不涉及原数据的修改，所以我们甚至不需要真的使用元组去存，而是可以直接俩 list 对齐去存储。</p>
<p>对下标进行排序的方案我们只是对一个整数数组进行的排序，得到的相当于复杂对象列表的一个<strong>排序视图</strong>，除了快之外，我们还可以在原列表的基础上按照不同的排序规则导出多个排序视图。</p>
<p>关于排序的一道例题可以看 <a href="https://codeforces.com/contest/652/problem/C">CF652C</a>。在本题中，你可以清楚地感知到快速读入、复杂对象排序、哈希等对 Python 运行速度的影响。</p>
<h2 id="多维数组">多维数组</h2>
<p>Python 实现类似多维数组的东西，最直观的写法是 list 套 list。但这个东西非常慢，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mn>5000</mn></mrow><annotation encoding="application/x-tex">n=5000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 有时候都会寄。list 第一维远大于第二维的时候（例如某些 ST 表或倍增的写法），很容易出现类似 C++ 的 Cache miss 的现象，且慢得更加明显。</p>
<p>在 DP 时，能用滚动数组就用滚动数组，这样少一维不只是空间优化了，时间也能快一些。</p>
<p><a href="https://codeforces.com/gym/105582/problem/C">CF105582C</a>，本题不使用滚动数组的话二进制拆分的多重背包跑不过去，用了之后才能过去。</p>
<p>list 套 list 还可以考虑拍平成一维的 list（这正好是 C 语言编译时对高维数组的处理方式），可以写一个下标变换函数 <code>f</code>，把 <code>dp[i][j][k]</code> 这种高维下标变成一维下标 <code>dp[f(i, j, k)]</code>。</p>
<p>拍平下标转化也是有时间开销的。如果是 DP 场景的话，可能只涉及加法和乘法，开销还好。但有的题需要用除法和取模去把一维下标还原成多维下标，这个时候就不太好说了。</p>
<h2 id="手写工具函数">手写工具函数</h2>
<p>在 LeetCode 周赛中，经常有朋友发现因为使用了 <code>max</code> 之类的函数而超时，这个时候需要改成手写 <code>fmax</code> 函数才能通过：</p>
<pre><code class="language-python">fmax = lambda a, b: a if a &gt; b else b
</code></pre>
<p>这个坑点在 LeetCode 上最明显，说是能差出 3 倍；在 Codeforces 上我测试时感觉差别比较小。</p>
<blockquote>
<p>值得一提的是，我在 Codeforces 上测试 <code>max</code> 时，对于相同的代码，选择 Python 3.10 和选择 PyPy 3 运行的时间分别是 600+ms 和 93ms，可见 PyPy 3 在算法竞赛中对 Python 有多重要。</p>
</blockquote>
<p>有时候 <code>max</code> 只是让程序 TLE 的最后一根稻草，或已经 TLE 之后的雪上加霜，这时候还需要看其他地方有没有可以优化的点。</p>
<h2 id="非递归">非递归</h2>
<h3 id="树相关问题的非递归">树相关问题的非递归</h3>
<p>直接使用 DFS 进行树的遍历，很有可能会爆栈 RE，改了栈空间大小可能也不好使（TLE MLE RE 快乐三选一）。有人说我们可以写 BFS 遍历呀，但是有时候我们就是需要按照自底向上的那个顺序去遍历结点（比如需要利用子树信息更新本结点信息的树形 DP），所以我们还是要想办法知道 DFS 的结点遍历顺序。</p>
<p>注意到 BFS 是一层一层访问的，其访问顺序反过来的话，是一种合理的自底向上的顺序，所以我们使用 BFS 去遍历树，得到一个序列 <code>order</code>，并记录 BFS 时每个结点的父亲，然后按照 <code>order</code> 的反序去遍历，就可以自底向上去做一些事情（子结点信息更新父亲信息）；按照 <code>order</code> 的正序遍历，则可以自顶向下做一些事情（父结点信息更新子结点信息）。</p>
<p>代码如下：</p>
<pre><code class="language-python">q = []
order = []
q.append(1)
parent = [-1 for _ in range(n + 1)]
parent[1] = 0
front = 0
while front &lt; len(q):
    u = q[front]
    front += 1
    order.append(u)
    for v in e[u]:
        if parent[v] == -1:
            parent[v] = u
            q.append(v)

reversed_order = order[::-1]

for u in reversed_order:
    ...
 
</code></pre>
<p>事实上，可以直接用 <code>order</code> 作为 BFS 的队列，无需单独开一个 <code>q</code>。</p>
<p>掌握了该项技能，就又可以过很多题了。</p>
<h2 id="数据结构">数据结构</h2>
<h2 id="对-python-速度的正确感知">对 Python 速度的正确感知</h2>
<h2 id="作用域相关的坑">作用域相关的坑</h2>
<h2 id="参考文献">参考文献</h2>
<ul>
<li>灵茶山艾府、小羊肖恩、conqueror_of_tourist 等经常使用 Python 做题/讲题的大佬的 AC 代码。</li>
<li>算法交流群里关于 Python 使用的聊天记录。</li>
<li>本人的实践经验。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在Codeforces随机刷题一年半，我学到了什么]]></title>
        <id>https://BUAA-Wander.github.io/post/what-did-i-learn-from-codeforces/</id>
        <link href="https://BUAA-Wander.github.io/post/what-did-i-learn-from-codeforces/">
        </link>
        <updated>2025-08-19T05:02:37.000Z</updated>
        <content type="html"><![CDATA[<h2 id="随机刷题前的我是什么样子">随机刷题前的我是什么样子</h2>
<p>笔者中学没有参与过信息学竞赛，大学没有参与过校级以上的 XCPC 相关赛事，为数不多的线下比赛经验是蓝桥杯以及 XCPC 校赛，最好战绩 C++ 研究生组北京省冠+国二（未公布 PDF 不知道具体名次），因此只能勉强算是一个算法爱好者。</p>
<p>笔者在 2024 年 1 月之前的情况大约如下：</p>
<ul>
<li>知识点：学完了 AcWing 算法基础+提高课以及算法竞赛进阶指南上 80% 左右的算法，还学了少量事实上对我来说 useless 的高级数据结构以及数学算法。平时做题主要是按照题单去做（即使是之前已经学过这个知识点了），即带着题目解法的提示去做题。</li>
<li>奖项：大四时拿了蓝桥杯 C++ A 组北京省一中游，时间冲突未参与国赛，有一定的写暴力的能力。</li>
<li>线上比赛：CF 1600 分的题目对我来说是个坎，需要 30 分钟以上才有可能做出来，但大部分时候是思路完全卡死做不出来。我从 2022 年底一直到 2023 年底，一年的时间都没在这个难度上有所突破。</li>
</ul>
<p>读者们应该发现了一个事实：我学习的知识点和表现出的解题能力差距有些大。从我现在的角度来看，24年初那会儿掌握的算法足够我去做 95% 以上的 2100 分以内的题目了，但我当时居然还经常被 1600 分的题目卡，着实有点搞笑了。</p>
<h2 id="开始改变训练方式">开始改变训练方式</h2>
<p>24 年 1 月，偶然间加入了<strong>小羊肖恩</strong>以及<strong>灵茶山艾府</strong>的算法交流群，两个群的每日活动都是写 CF，羊村是每日两羊蹄，灵茶山是每日一杯茶，题目的难度如下：</p>
<table>
<thead>
<tr>
<th>星期</th>
<th>羊村难度</th>
<th>灵茶山难度</th>
</tr>
</thead>
<tbody>
<tr>
<td>星期一</td>
<td>1800 1900</td>
<td>1300-1400</td>
</tr>
<tr>
<td>星期二</td>
<td>1800 1900</td>
<td>1400-1500</td>
</tr>
<tr>
<td>星期三</td>
<td>1700 2000</td>
<td>1600-1800</td>
</tr>
<tr>
<td>星期四</td>
<td>1700 2000</td>
<td>1900-2100</td>
</tr>
<tr>
<td>星期五</td>
<td>1600 2100+</td>
<td>2400+</td>
</tr>
<tr>
<td>星期六</td>
<td>1600 2200+</td>
<td>休息</td>
</tr>
<tr>
<td>星期日</td>
<td>休息</td>
<td>休息</td>
</tr>
</tbody>
</table>
<p>由于 CF 上的题我做的很差，所以最开始每日的活动我参与得非常吃力：羊蹄很多时候当天只能完成一道，周四周五的茶对我来说也颇有挑战，尤其是周五的茶我大部分时候是不做的。后面羊蹄开了专门的 GitHub 仓库，在连续打卡的激励下，我开始稳定地每日完成至少一道羊蹄，虽然只是写 1600-1800 分的题目，但这个分数已经是我 rating + 200 到 400 的题目了，所以做下来仍然可以有所进步。</p>
<h2 id="不断突破自我">不断突破自我</h2>
<p>熬过去了两个多月，在这样写了 200 题之后，思考时有了明显的进步。我发现 1600 分的题目 10 道里我可能只有一两道不会了，1800 分左右的题目我有时候也可以自己想出来了。之后的一段时间里，我开始尝试每日啃两道羊蹄，茶也争取周一到周四全勤，周五的题至少看一看（不止一位大佬在群里说过，什么题都可以先花几分钟看一看，再决定做不做）。</p>
<p>到了五六月份的时候，我的 LeetCode 周赛打到了 2500 多分，相比于一年前停滞不前的 2300 多分，可以感觉出来有一些进步，但说不清楚进步在哪里了，因为我觉得自己这半年并没有学到什么新的算法，似乎只是“注意力”有了一些提升，能够发现之前发现不了的切入点。</p>
<p>又经过了一个暑假的积累，到了 2024 年 10 月，我的 CF 总题量达到了 1000 题，其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≥</mo></mrow><annotation encoding="application/x-tex">\ge</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≥</span></span></span></span> 1500 的题 637 道，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≥</mo></mrow><annotation encoding="application/x-tex">\ge</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≥</span></span></span></span> 1800 的题 293 道，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≥</mo></mrow><annotation encoding="application/x-tex">\ge</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≥</span></span></span></span> 2000 的题 120 道。这个时候，我能明显感觉到自己找切入点时的“注意力”吊打进群前的自己。在这段时间，我参与了一场 CF div2 的比赛，在这之前我已经一年没有打 rated 比赛了。在这场比赛中，我解决了 ABC1E1 4 道题目，并且由于 E1 解决的时间比较早，导致我这场的表现分达到了惊人的 2160 分！在这之前我最好的发挥仅仅是 AK div4 打到1700 左右的蓝名表现分。这时，我是确信自己是真的进步了，并且我相信按照这个训练计划继续走，我还有不小的提升空间。</p>
<p>2024 年 11 月，我第 4 次参与校赛，在预赛解决了 9 题，排名前 20，后面的决赛解决了 7 题（共 9 题），排名第 7，拿到了校赛一等奖，在此之前我最好成绩是校赛 20 多名三等奖。线下的比赛是很有说服力的，我能和那些搞过 OI 的同学在校赛的赛制和难度下能打得有来有回了，这给了我很大的信心。另外从平时训练情况上来看，我似乎可以比较稳地在非赛时吃掉 1800 分以内题目了，2000 分以内的题目也经常有一战之力。</p>
<p>2025 年 4 月蓝桥杯省赛，我成功 AK，拿到了研究生组的第一名，又一次线下赛的成功经历。6 月国赛打得确实下饭了，或许是起得太早去考场导致脑子昏昏沉沉，也可能是水平确实还没到，最后只拿了国二。</p>
<p>之后，就很少有线下线上比赛的经历了，线上没比赛主要是晚上睡得比较早，所以不参加 CF 的比赛（之前晚上参加打得非常下饭，只能打出 1700 不到的表现）。在水群时，有几位橙名的群友有说我现在的水平应该回归打几场比赛就有紫名了，但可惜目前作息实在是不太适合打。或许等后边作息发生一些变化时可以冲一冲，作为爱好者咱也是希望能上个紫的，至于橙名，目前我感觉自己的水平还够不到，我自己平时单题训练时都还没有稳定切掉 2000 分以及以上题目的能力。</p>
<p>附上我目前的训练情况截图：</p>
<figure data-type="image" tabindex="1"><img src="https://BUAA-Wander.github.io/post-images/1755584273526.png" alt="训练情况" loading="lazy"></figure>
<h2 id="增加套路的学习和积累">增加套路的学习和积累</h2>
<p>TODO，做 ABC</p>
<h2 id="到目前为止的收获">到目前为止的收获</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2025年8月算法好题集锦]]></title>
        <id>https://BUAA-Wander.github.io/post/2025-08-good-problems/</id>
        <link href="https://BUAA-Wander.github.io/post/2025-08-good-problems/">
        </link>
        <updated>2025-08-19T03:56:53.000Z</updated>
        <content type="html"><![CDATA[<p>Codeforces：</p>
<table>
<thead>
<tr>
<th>题目链接</th>
<th>难度分</th>
<th>Tag</th>
<th>题解</th>
<th>学到的东西</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://codeforces.com/contest/1896/problem/E">CF1896E</a></td>
<td>2100</td>
<td>破环为链、树状数组</td>
<td>---</td>
<td>---</td>
</tr>
<tr>
<td><a href="https://codeforces.com/contest/1913/problem/E">CF1913E</a></td>
<td>2400</td>
<td>网络流建模</td>
<td>---</td>
<td>将所有边权同时加同一个数使得所有边权为正</td>
</tr>
<tr>
<td><a href="https://codeforces.com/contest/271/problem/E">CF271E</a></td>
<td>2200</td>
<td>数论、构造</td>
<td>---</td>
<td>---</td>
</tr>
<tr>
<td><a href="https://codeforces.com/contest/1041/problem/E">CF1041E</a></td>
<td>2200</td>
<td>树、构造</td>
<td>---</td>
<td>---</td>
</tr>
<tr>
<td><a href="https://codeforces.com/contest/652/problem/C">CF652C</a></td>
<td>1800</td>
<td>排序</td>
<td>---</td>
<td>Python如何实现小常数排序</td>
</tr>
<tr>
<td><a href="https://codeforces.com/contest/2129/problem/C2">CF2129C</a></td>
<td>2000</td>
<td>构造、位运算</td>
<td>---</td>
<td>独热编码</td>
</tr>
<tr>
<td><a href="https://codeforces.com/contest/76/problem/A">CF76A</a></td>
<td>2200</td>
<td>瓶颈生成树</td>
<td>---</td>
<td>---</td>
</tr>
<tr>
<td><a href="https://codeforces.com/contest/1207/problem/F">CF1207F</a></td>
<td>2100</td>
<td>根号分治</td>
<td>---</td>
<td>问题求解的复杂度是两部分的乘积，乘积为定值</td>
</tr>
<tr>
<td><a href="https://codeforces.com/problemset/problem/763/A">CF763A</a></td>
<td>1600</td>
<td>根号分治、树形DP</td>
<td>---</td>
<td></td>
</tr>
<tr>
<td><a href="https://codeforces.com/problemset/problem/203/D">CF203D</a></td>
<td>1700</td>
<td>速度分解</td>
<td>---</td>
<td></td>
</tr>
<tr>
<td><a href="https://codeforces.com/problemset/problem/95/C">CF95C</a></td>
<td>1900</td>
<td>最短路</td>
<td>---</td>
<td>同时涉及到距离和费用，先求最短距离得到关于费用的图，再求费用最短路</td>
</tr>
<tr>
<td><a href="https://codeforces.com/contest/2071/problem/D1">CF2071D1</a></td>
<td>1800</td>
<td>递归</td>
<td>---</td>
<td>手玩，发现消去规律</td>
</tr>
<tr>
<td><a href="https://codeforces.com/contest/201/problem/C">CF201C</a></td>
<td>2000</td>
<td>DP</td>
<td>---</td>
<td>从i点开始走虽然可以来回跨着i折返，但可以转化成不折返，所以只需考虑不折返</td>
</tr>
<tr>
<td><a href="https://codeforces.com/contest/1463/problem/E">CF1463E</a></td>
<td>2400</td>
<td>缩点、拓扑排序</td>
<td>---</td>
<td>邻接关系显然更强，我们可以把这部分做一个缩点，就可以优先满足这类约束了，24年校赛E题也是这个思路</td>
</tr>
<tr>
<td><a href="https://codeforces.com/problemset/problem/2077/C">CF2077C</a></td>
<td>2300</td>
<td>组合数学、推公式</td>
<td><a href="https://github.com/Yawn-Sean/Daily_CF_Problems/blob/main/daily_problems/2025/08/0829/solution/cf2077c.md">羊的题解</a></td>
<td>首先要观察出每个序列的答案只和01个数有关（介值定理+均值不等式），才有资格进入后续推式子环节。推式子用到了二项式定理+求导的技巧</td>
</tr>
<tr>
<td><a href="https://codeforces.com/contest/332/problem/D">CF332D</a></td>
<td>2400</td>
<td>贡献法</td>
<td><a href="https://github.com/Yawn-Sean/Daily_CF_Problems/blob/main/daily_problems/2025/08/0830/solution/cf332d.md">性质分析</a></td>
<td>比较套路的分析每条边贡献多少次的题目，奇妙之处在于答案可以直接浮点数取整输出表示出来</td>
</tr>
<tr>
<td><a href="https://codeforces.com/contest/1469/problem/E">CF1469E</a></td>
<td>2400</td>
<td>字典序、贪心</td>
<td>---</td>
<td>关键在于发现无解的条件，通过观察样例可以，把存在问题改为任意问题也可以，后边就是套路的按位贪心</td>
</tr>
</tbody>
</table>
<p>AtCoder：</p>
<blockquote>
<p>最近在备赛 CSP-S，打 ABC 复习知识点，感觉 EF 题都挺不错的，能够复习到很多好久不见的技巧，难度上基本是绿题（普及+/提高），对 CSP-S 拿低分省一还是很有用的。</p>
</blockquote>
<table>
<thead>
<tr>
<th>题目链接</th>
<th>难度分</th>
<th>Tag</th>
<th>题解</th>
<th>学到的东西</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://atcoder.jp/contests/abc419/tasks/abc419_e">ABC419E</a></td>
<td>洛谷绿</td>
<td>背包DP</td>
<td>---</td>
<td>需要注意到相距为L的两个元素之间的关系，从而才能转化成分组背包</td>
</tr>
<tr>
<td><a href="https://atcoder.jp/contests/abc418/tasks/abc418_e">ABC418E</a></td>
<td>洛谷黄</td>
<td>哈希、斜率</td>
<td>---</td>
<td>使用GCD并调整符号表示斜率，以及自定义结构使用umap如何写哈希</td>
</tr>
<tr>
<td><a href="https://atcoder.jp/contests/abc417/tasks/abc417_f">ABC417F</a></td>
<td>洛谷绿</td>
<td>期望、线段树</td>
<td>---</td>
<td>期望的线性性</td>
</tr>
<tr>
<td><a href="https://atcoder.jp/contests/abc416/tasks/abc416_e">ABC416E</a></td>
<td>洛谷绿</td>
<td>最短路</td>
<td>---</td>
<td>虚点最短路、加边后松弛操作可以快速更新最短路</td>
</tr>
<tr>
<td><a href="https://atcoder.jp/contests/abc369/tasks/abc369_e">ABC369E</a></td>
<td>洛谷绿</td>
<td>最短路、暴力枚举</td>
<td><a href="https://www.luogu.com.cn/article/468hpmms">沃若的题解</a></td>
<td>一题多解</td>
</tr>
<tr>
<td><a href="https://atcoder.jp/contests/abc366/tasks/abc366_e">ABC366E</a></td>
<td>洛谷绿</td>
<td>推公式</td>
<td></td>
<td>遇到曼哈顿距离并非一定要考虑转切比雪夫距离处理</td>
</tr>
<tr>
<td><a href="https://atcoder.jp/contests/abc406/tasks/abc406_f">ABC406F</a></td>
<td>洛谷绿</td>
<td>DFS序、线段树</td>
<td></td>
<td>板子太久没写了，注意下标</td>
</tr>
<tr>
<td><a href="https://atcoder.jp/contests/abc403/tasks/abc403_f">ABC403F</a></td>
<td>洛谷绿</td>
<td>表达式解析、递归、DP</td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="https://atcoder.jp/contests/abc402/tasks/abc402_f">ABC402F</a></td>
<td>洛谷绿</td>
<td>双向BFS、二分</td>
<td></td>
<td>实现时，可以先搜一边，到某个深度停止，这一边都搜完之后再写另一边的搜索</td>
</tr>
<tr>
<td><a href="https://atcoder.jp/contests/abc389/tasks/abc389_e">ABC389E</a></td>
<td>洛谷蓝</td>
<td>贪心、二分</td>
<td></td>
<td>总代价是关于个数的函数，做差可求得每多拿一件的单价，然后可以贪心去拿</td>
</tr>
<tr>
<td><a href="https://atcoder.jp/contests/abc399/tasks/abc399_f">ABC399F</a></td>
<td>洛谷绿</td>
<td>推公式、二项式定理、求和换序</td>
<td></td>
<td>单独某个数的贡献并不容易算，于是切入点改为枚举右，快速把所有左的结果算出来</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Gridea+GitHub Pages+主题配置踩坑记录]]></title>
        <id>https://BUAA-Wander.github.io/post/gridea-blog-config-tutorial/</id>
        <link href="https://BUAA-Wander.github.io/post/gridea-blog-config-tutorial/">
        </link>
        <updated>2025-08-19T00:24:10.000Z</updated>
        <content type="html"><![CDATA[<h2 id="concise-主题公式出现两次">Concise 主题公式出现两次</h2>
<p>效果类似于把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> 渲染成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>S。</p>
<p>解决方案是将 <code>concise\templates\includes\head.ejs</code> 文件增加这三行内容：</p>
<pre><code class="language-html">&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/katex.min.css&quot;&gt;
&lt;script defer src=&quot;https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/katex.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js&quot; async&gt;&lt;/script&gt;
</code></pre>
<p>其他主题遇到了类似问题也可以尝试这样去修复一下。</p>
<blockquote>
<p>有人问 <code>concise\templates\includes\head.ejs</code> 在哪里？这个可以在 Gridea 中查看站点源文件的存储路径，我的保持了默认路径，大概长这样： <code>C:/Users/WanderOvO/Documents/Gridea</code>。去里面的 <code>themes</code> 目录下找到对应的主题即可，想换主题也是把主题解压在这里。</p>
</blockquote>
<h2 id="concise-主题代码块颜色修改">Concise 主题代码块颜色修改</h2>
<p>你需要修改 <code>concise\assets\styles\components\code-hljs-highlight.less</code> 中的内容。只要知道需要改这个文件，里面该改哪些东西是容易看出来的，实在大不了可以挨个试，或者网上找一份现成的复制粘贴进来，抑或是让 DeepSeek 帮你推荐一些配色方案。</p>
<blockquote>
<p>可以使用 F12 选择对应的元素，在前端直接改 CSS，确定到底是改哪个 CSS 才能起作用，然后去主题文件夹中找到那个文件修改即可。<br>
有的主题的配置可以在 Gridea 客户端的自定义配置页面直接改，比如 Next 主题的，这样就不用自己去翻代码改了（改了可能也被覆盖了没用）。</p>
</blockquote>
<h2 id="github-pages-css-加载不出来文章跳转-404">GitHub Pages css 加载不出来，文章跳转 404</h2>
<p>通过 F12 看前端网络请求，发现是我在 Gridea 中配置的域名错了，导致访问仓库中的文件都是 404。在 Gridea 的远程管理页面需要填一个域名，这个域名指的是<strong>你的博客的域名</strong>，比如 <code>BUAA-Wander.github.io</code>，而<strong>不是你的仓库的地址</strong>，我最开始不小心复制成了仓库的地址，导致 GET 请求一直在请求类似于 <code>https://github.com/BUAA-Wander/BUAA-Wander.github.io/post/article-title</code>  之类的东西，但实际上应该请求 <code>https://BUAA-Wander.github.io/post/article-title</code>，过了很久才反应过来。</p>
<p>写错的时候，默认只能加载出根目录的 <code>index.html</code>，其他的跳转和加载 CSS 的路径都是错的，所以访问文章会 404，CSS 文件也请求不到。</p>
<p>但是不写错域名有时候似乎也会出现 CSS 突然不管用的问题，具体解决方案可以在搜索引擎上搜一下。</p>
<h2 id="各种修改不生效的问题">各种修改不生效的问题</h2>
<p>请打开 F12 开发者模式，<strong>禁用缓存</strong>然后刷新。</p>
<p>如果是 GitHub Pages 修改不生效，除了缓存问题，还有一个原因是<strong>还没部署上</strong>，可以等 2 分钟。</p>
<h2 id="同步到远端失败">同步到远端失败</h2>
<p>可能是网络问题，需要在 Gridea 中配置 https 代理，例如我的梯子需要配置 127.0.0.1:10809</p>
<h2 id="备份与转移">备份与转移</h2>
<p>需要对 <code>C:\Users\WanderOvO\Documents\Gridea</code> 目录进行备份，其中有文章、图片、已经魔改好的博客主题。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于]]></title>
        <id>https://BUAA-Wander.github.io/post/about/</id>
        <link href="https://BUAA-Wander.github.io/post/about/">
        </link>
        <updated>2025-08-18T11:09:48.000Z</updated>
        <content type="html"><![CDATA[<h2 id="关于本站">🏠 关于本站</h2>
<p>WanderOvO 学习算法、做项目、科研过程中的一些思考和体会。</p>
<p><a href="https://www.cnblogs.com/BUAA-Wander">古早时期写过的博客</a>，记录的主要内容是北航计算机学院本科专业实验相关的笔记和体会。老博客暂时没空翻修，里面的内容<strong>有点跟不上实验版本迭代</strong>了。由于笔者当时水平一般，在博客里记录的主要是实验中遇到的一些<strong>零碎性的知识</strong>，并不是在写系统性的实验教程，所以想通过读这些博客从 0 到 1 完成实验的读者或许会有点失望。但好在在笔者之后的年级里，越来越多的同学创作了高质量的博客，相信读这些足以帮助各位度过难关了。当然，老博客在<strong>实验踩坑</strong>方面记录的内容倒是还有很多可以参考的地方，如果有兴趣可以去看看。</p>
<h2 id="博主是谁">👨‍💻 博主是谁</h2>
<p>WanderOvO，北航计算机学院本硕，目前正在上研二，在做 AI 软件测试相关研究，预计2027年6月毕业。</p>
<h2 id="兴趣爱好">⛹ 兴趣爱好</h2>
<ul>
<li>运动：乒乓球、游泳、跑步</li>
<li>音乐：唱歌</li>
<li>其他：刷 Codeforces，海龟汤、躲猫猫、恐怖小故事</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[第16届蓝桥杯游记]]></title>
        <id>https://BUAA-Wander.github.io/post/16th-basketball-cup-experience/</id>
        <link href="https://BUAA-Wander.github.io/post/16th-basketball-cup-experience/">
        </link>
        <updated>2025-05-10T13:28:44.000Z</updated>
        <content type="html"><![CDATA[<h2 id="自我介绍">自我介绍</h2>
<ul>
<li>我是 WanderOvO，北航本硕计算机，目前在读研一。</li>
<li>研究过模型驱动的软件工程需求建模，但是感觉很玄学就放弃了，后边准备做软件测试相关的研究。</li>
<li>没有参加过 OI/XCPC 但是是个算法爱好者。</li>
</ul>
<h2 id="省赛赛前">省赛赛前</h2>
<p>今年已经是研究生了，所以报了北京 C++ 研究生组。由于大风天气，北京第一场没有考成，当时感觉很郁闷，因为当时 OI 赛制的模拟套题刚做了好几套，状态很好且考场策略的执行很到位，延期我担心自己状态会掉。</p>
<p>等待第二场比赛的期间没有再做套题（因为有课程和科研压力），甚至懒得看第一场考了什么题，只是从路边听来了一些难度评价，似乎是不太难的样子。</p>
<p>赛前训练主要还是跟着<a href="https://docs.qq.com/sheet/DWGFoRGVZRmxNaXFz">灵茶山艾府</a>和<a href="https://github.com/Yawn-Sean/Daily_CF_Problems/">小羊肖恩</a>平均每天花 2 小时在 CF 上<strong>写 2-3 道精选的 1600-2100 分的题目</strong>。其实这个刷题习惯已经坚持了一年多了，在一年多里这个分数段的题目我写了 800 道左右，几乎没有学习任何新的算法和数据结构，也只参加了三五场阳间时间的 CF（晚上 10 点之后脑子很乱，所以几乎不在 10 点以后写代码）。</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.luogu.com.cn/upload/image_hosting/7yh69jkw.png" alt="" loading="lazy"></figure>
<p>这个训练的效果也是比较显著的，我从训练前校赛只能打三等奖（30 名左右）变成了校赛一等奖（第 7 名），从 CF 1400 分的题都写不动，到现在大部分时候能拿下 1800 分以内的题目。我没打过 OI，也没有参加过 XCPC，所以能到这个水平我个人还是满意的。</p>
<p>延期这段时间整个人的状态就是很松弛，就像沙鲁游戏前悟空悟饭每天保持超级赛亚人状态生活的感觉那样，每天会做点训练保持手感，不强迫自己写比较消耗脑力的题目。</p>
<h2 id="省赛赛时">省赛赛时</h2>
<p>解压题目，开始执行定好的比赛策略：</p>
<ul>
<li>前 15 分钟把所有题目看一遍，想一下每个题最简单的 1-2 档分怎么做，然后发现整套题目意外地简单。</li>
<li>之后用了 1 小时 10 分钟左右，写完了前五道题的正解以及最后三题的暴力。</li>
<li>然后使用 15 分钟的时间，想到了基因配对那道题其实就是剥洋葱，每层都要比上一层选得不小，而第一层选的就是最大字符，所以事实上答案就是输出字符串中所有的字典序最大的字符即可。估分不超过 CF 1600 分。</li>
<li>然后开始想栈与乘积那道题的正解，发现如果没有 0 和 1 的话，至多枚举栈顶的 32 的数就会 overflow，所以关键在于 0 和 1 怎么处理。我维护了最接近栈顶的 0 的位置，以及每个 &gt;= 2 的数的下面第一个 &gt;= 2 的数，这样就跳过了 1，然后就做出来了。怕写挂了，于是把对拍写好挂上了，拍了 5 分钟没拍出错误就认为过了。估分不超过 CF 1800 分。</li>
<li>最后开始做翻转硬币那道题，发现其实就是个维护前两行状态的 DP，羊村里考前有人讨论过类似的。这题写起来稍微有点麻烦，当时应该在场上实现了 20 分钟以上，debug 也 de 了一会儿，然后挂上对拍，拍了 5 分钟没错误。估分应该难度在 CF 2000 分以内。</li>
<li>至此，我觉得自己 AK 了省赛，这个时候大概还有 1 个半小时结束。由于题目过于简单，我害怕不 AK 进不了决赛，于是又硬坐了半小时，把前面几个题重新读了几遍，每个题手动测了一些样例，能对拍的也都拍了，12 点感觉实在没问题就出场了。</li>
</ul>
<h2 id="省赛出分">省赛出分</h2>
<p>5 月 9 号终于出分了，发现是北京 C++ 研究生组的冠军，获奖名单第一个名字就是我，估计是同样 AK 但是我准考证号的字典序比较小吧，还是很有运气因素的。我从 CPC Finder 上查了一下前几名的其他同学，发现基本都是拿过区域赛金银牌的，我能登顶纯粹是因为题目区分度不好，但凡这套题里面再将 2 道简单题换成 CF 2000 分左右的题目，我肯定就来不及 AK 了。</p>
<p>值得一提的是，这也是我第一次拿 rank 1，之前无论是线上还是线下比赛，无论是简单还是难的比赛，都没有拿过前五以内的成绩（似乎最好成绩是校赛第 7），这也是一次历史性突破了！</p>
<p>突然就想到了高中数学老师兼班主任之前说的一句话：“你高考数学考了 145 分甚至 149 分，可能过了很多年之后高考数学满分不是 150 了，这样你给你的孩子说的时候，ta 一下子反应不过来你多厉害；但假如你考了满分，那么不管过去多少年，你都可以不回答具体数字直接给他们说自己考了满分，无需任何其他解释”。那年高考，我数学考了全校唯二的满分。今天我侥幸拿了省赛第一，不管蓝桥杯是个多水的比赛，不管它的省一有多好拿，以后我也只要说自己是省赛第一名就可以了。</p>
<h2 id="省赛总结与展望">省赛总结与展望</h2>
<p>这次能打出不错的成绩，我觉得有这么几点原因：</p>
<ul>
<li>题目简单，在我的能力范围内可以 AK。</li>
<li>最近一年来的训练放松但有效，基本算是在稳步突破自己的舒适区。</li>
<li>赛前对省赛难度题目的 OI 赛制进行了一些针对性模拟，找到了适合自己的做题节奏。</li>
</ul>
<p>国赛很快就要来了，事实上这才是我第一次参加国赛，希望能够保国二争国一吧。</p>
<p>等国赛之后，自己可能会对训练稍做调整，具体来说是：</p>
<ul>
<li>把做题的难度调整到 1900-2300 分，原因是 1800 分以内的题目对我的提升不明显了，但 2400 分以及更难的题目对于我这种不打 OI/XCPC 的研究生来说有点过了。</li>
<li>多参加 ABC 等阳间时间的比赛，打好基础。</li>
</ul>
<p>希望新训练计划执行半年左右的时候，我也能够靠 div2 冲上一次橙名吧，加油！</p>
<h2 id="国赛后续">国赛后续</h2>
<p>6 月 10 号去首经贸参与了蓝桥杯国赛，由于起太早了去考场感觉很懵，打得有点下饭，至少有一道该想出正解的题目没有做出来，最后悲提国二。事实上就算做出来那道题，我觉得自己也并不能拿到国一，往年国一只有 10 人左右，且我人肉了一下各省省赛前排选手，发现拿过 XCPC 区域赛银牌以及以上的同学已经不止 10 人了，现在我的真实实力只能和铜牌选手过过招。唉，C++ 研究生组拿国一的难度真不比 C++ A 组简单多少。</p>
<p>获奖名单至今没有公布，感觉蓝桥杯要烂完了，明年还参不参加还是个未知数，总感觉没有个国一的奖有些遗憾呢...明年再说吧！</p>
]]></content>
    </entry>
</feed>