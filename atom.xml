<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://BUAA-Wander.github.io</id>
    <title>WanderOvO</title>
    <updated>2026-01-02T02:57:28.218Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://BUAA-Wander.github.io"/>
    <link rel="self" href="https://BUAA-Wander.github.io/atom.xml"/>
    <subtitle>写点代码玩玩</subtitle>
    <logo>https://BUAA-Wander.github.io/images/avatar.png</logo>
    <icon>https://BUAA-Wander.github.io/favicon.ico</icon>
    <rights>All rights reserved 2026, WanderOvO</rights>
    <entry>
        <title type="html"><![CDATA[2026年1月算法好题集锦]]></title>
        <id>https://BUAA-Wander.github.io/post/2026-01-good-problems/</id>
        <link href="https://BUAA-Wander.github.io/post/2026-01-good-problems/">
        </link>
        <updated>2026-01-01T01:09:57.000Z</updated>
        <content type="html"><![CDATA[<p>Codeforces：</p>
<blockquote>
<p>gym 中题目难度分是我根据体感估计的。</p>
</blockquote>
<table>
<thead>
<tr>
<th>题目链接</th>
<th>难度分</th>
<th>Tag</th>
<th>题解</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://codeforces.com/gym/104468/problem/A">GYM104469A</a></td>
<td>1900</td>
<td>2-SAT、并查集</td>
<td><a href="https://github.com/Yawn-Sean/Daily_CF_Problems/blob/main/daily_problems/2026/01/0102/solution/cf104468a.md">题解</a></td>
<td>首先应该分析出来对于某个数字来说，其对应的那两个坐标的交换情况（都换、都不换、换一个），然后发现这就是一个 2-SAT 问题。但由于本题的关系比较特殊，所以可以使用并查集维护，无需 tarjan。</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>其他题目：</p>
<table>
<thead>
<tr>
<th>题目链接</th>
<th>难度分</th>
<th>Tag</th>
<th>题解</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2025年12月算法好题集锦]]></title>
        <id>https://BUAA-Wander.github.io/post/2025-12-good-problems/</id>
        <link href="https://BUAA-Wander.github.io/post/2025-12-good-problems/">
        </link>
        <updated>2025-12-01T01:09:57.000Z</updated>
        <content type="html"><![CDATA[<p>Codeforces：</p>
<blockquote>
<p>gym 中题目难度分是我根据体感估计的。</p>
</blockquote>
<table>
<thead>
<tr>
<th>题目链接</th>
<th>难度分</th>
<th>Tag</th>
<th>题解</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://codeforces.com/gym/105863/problem/F">GYM105863F</a></td>
<td>1700</td>
<td>数学、取模、二分</td>
<td></td>
<td>一个数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 取模后变小，结果应该至多是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的一半，所以真正有用的取模次数是对数级别的。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/105863/problem/G">GYM105863G</a></td>
<td>1800</td>
<td>数学、数列求和、贡献法</td>
<td></td>
<td>我们考虑第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个位置填 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>，且满足 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>min</mi><mo>⁡</mo><mo>(</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>a</mi><mi>i</mi></msub><mo>)</mo><mo>=</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">\min(a_1, ...a_i) = j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 贡献了多少次，可以发现就是前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个必须填不小于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>，后 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">n - i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个随便填，第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个等于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 的方案数。对这个东西进行求和，发现只要先枚举 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 再枚举 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 就可以等比数列求和求解了。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/problemset/problem/1912/K">CF1912K</a></td>
<td>1800</td>
<td>状态机DP</td>
<td></td>
<td>满足条件的子序列连续 3 个数中必须有偶数个奇数。我们考虑以第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个数结尾的满足条件的子序列个数，则可以枚举上一个结尾 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>，看如何贡献。经过分析，发现我们其实只关心最后 3 个数的奇偶性，将这个信息设计到状态中即可。另外，上面少考虑了从只有 2 个数的序列转移过来的情况，所以还要补充上这种。总的来说需要维护结尾为 1，2，3 的子序列的末尾奇偶性信息。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/106260/attachments">GYM106260A</a></td>
<td>1700</td>
<td>期望</td>
<td></td>
<td>有很多切入点，但是能做的切入点是，我们考虑每个点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 贡献的操作次数的期望。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 有贡献当且仅当序列中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 前面没出现自己的祖先。假设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 的深度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mi>u</mi></msub></mrow><annotation encoding="application/x-tex">d_u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，则随机出一个满足上述条件的排列的概率是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><msub><mi>d</mi><mi>u</mi></msub></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{d_u}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2902079999999998em;vertical-align:-0.44509999999999994em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.44509999999999994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，原因是我们只需要考虑从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 这条链上的点，每个点排在第一位的概率都是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><msub><mi>d</mi><mi>u</mi></msub></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{d_u}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2902079999999998em;vertical-align:-0.44509999999999994em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.44509999999999994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>。其他点怎么排是无所谓的，相当于可以分子分母约掉，所以只要把这些倒数求和就是答案了。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/105874/problem/E">CF105874E</a></td>
<td>1900</td>
<td>线段树、离线、素数、莫队</td>
<td></td>
<td>大号版的 HH 的项链，我们对询问离线，按照右端点排序，维护每个素因子最后一次出现的位置，并用线段树维护位置上的素数的区间乘积即可解决本题。如果数据范围再小一点，则可以用莫队做，因为端点移动时更新信息是容易的。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/105845/problem/F">GYM105845F</a></td>
<td>1800</td>
<td>DP、数学、测试</td>
<td></td>
<td>状态容易设，关键是如何高效转移。我们注意到能转移过来的一定是前缀和模 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 同余的，所以不妨开一个二维数组，专门维护模 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 余 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 的那些 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span></span></span></span> 值的和，这样就可以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 转移了。注意，本题空间比较小，无脑开 long long 且不压空间会 MLE，但如果你使用的是 vector 而不是静态数组，则还能侥幸过几个点。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/105789/problem/K">GYM105789K</a></td>
<td>2000</td>
<td>模拟、贪心、分类讨论、测试、教学</td>
<td></td>
<td>首先应该发现，如果每轮的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span> 严格变大的话，至多模拟根号轮就可以，如果不变的话直接计算就可以。对于严格变大的情况，显然是先加后乘能最大化一轮的输出，但最后一轮需要特殊处理。本质上，最后一轮也是用最大的几个加法和最大的几个乘法先强化，然后再攻击。本题 corner case 非常多，比如啥时候无解、会不会爆 long long、最后一轮的处理...如果是正式比赛的话通过率应该惨不忍睹。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/105790/problem/K">GYM105790K</a></td>
<td>1600</td>
<td>数论、数学</td>
<td></td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mi>b</mi></msup></mrow><annotation encoding="application/x-tex">a^b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span></span></span></span></span></span></span> 模 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>o</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">mod</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span></span></span></span>，但 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 是个很大的斐波那契数，怎么办？注意到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>≡</mo><mn>1</mn><mo>(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">a^{m - 1} \equiv 1 (mod\ m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>，所以可以在计算 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 时对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">m - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 取模，用这个取模后的结果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> 求 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mi>r</mi></msup></mrow><annotation encoding="application/x-tex">a^r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span></span></span></span></span></span></span>。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/contest/1428/problem/E">CF1428E</a></td>
<td>2200</td>
<td>动态贪心</td>
<td></td>
<td>考虑到代价函数是下凸的，所以假如把某个胡萝卜拆成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">cnt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span></span></span></span> 段，那么一定是尽量平分才能让这个胡萝卜的总代价最小。进一步，我们还应该发现，切成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">cnt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span></span></span></span> 段肯定比切成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">cnt + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69841em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 段代价大，并且，这个代价之差是逐渐变小的。因此，我们可以动态的贪心，维护每个胡萝卜当前段数与再切一段后的代价之差，每次贪心地选最大的那个切就好了。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/106270/problem/H">GYM106270H</a></td>
<td>1800</td>
<td>数论、反悔贪心</td>
<td></td>
<td>每个数有两种变换方式，各自的代价可以算出来。然后发现这个就类似 CSP-S 的 T1 了，我们可以先大家都无脑选最优，然后按照两种方式的差值排序反悔即可。记得预处理每个数的最小素因数。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/105262/problem/G">GYM105262G</a></td>
<td>1700</td>
<td>前缀和、哈希、马拉车</td>
<td></td>
<td>用哈希或马拉车求回文半径，然后用加权前缀和算结果就行。注意别推错了式子，哈希要用双哈希（1e12 个区间）。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/problemset/problem/2018/B">CF2018B</a></td>
<td>1900</td>
<td>贪心、区间合并</td>
<td></td>
<td>首先应该注意到，不管选谁为起点，我们每次都是覆盖连续的一段区间。走 k 步则区间长度为 k，并且要把所有 ddl 不超过 k 的都包含进来，所以我们可以预处理所有 ddl 不超过 k 的点的最小左端点和最大右端点。假设不超过 k 的点的范围是 l 到 r，则合法起始点的左端点至多可以是 r - k + 1，右端点至多可以到 l + k - 1。把这些合法起始点的区间交一下就是答案了。如果读错题看成了树上问题，可以出一道固定起始点，判断是否可行的问题，用贪心+倍增搞。</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>其他题目：</p>
<table>
<thead>
<tr>
<th>题目链接</th>
<th>难度</th>
<th>Tag</th>
<th>题解</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://www.luogu.com.cn/problem/P9753">P9753</a></td>
<td>蓝</td>
<td>括号序列、栈、哈希、DP、测试</td>
<td></td>
<td>首先应该知道可以用类似括号序列栈模拟的方式判断一个子串是否合法。然后，应该意识到，可以枚举开头，然后从这个开头开始用栈模拟，每当栈为空时，说明以这个字符开头的合法子串数量又 + 1 了。进一步，应该意识到，每当遇到一次之前出现过的栈的状态，就说明末端又消掉了一个子串，而这个状态出现的次数就是以当前字符结尾的合法子串个数。另外还有一个 DP 做法。关于测试，随机的字符集太大的话就会和 A 性质差不多了，基本都是相邻的或者没有，所以字符集要小一点去对拍。</td>
</tr>
<tr>
<td><a href="https://www.luogu.com.cn/problem/AT_abc312_f">ABC312F</a></td>
<td>绿</td>
<td>贪心、排序</td>
<td></td>
<td>本题有若干种做法，但出发点是一样的， 都是先枚举某种物品的个数，然后想办法快速算出其他两种的个数，并且选的时候优先选值更大的。我的做法是枚举有几个需要开罐器的罐头，这样可以直接算出需要拿几个开罐器，这样不需要开罐器的罐头个数也就呼之欲出了。题解区还提供了枚举其他物品的做法。</td>
</tr>
<tr>
<td><a href="https://atcoder.jp/contests/abc438/tasks/abc438_f">ABC438F</a></td>
<td>蓝</td>
<td>贡献法、MEX、分类讨论、LCA</td>
<td><a href="https://www.luogu.com.cn/article/l20vk4lt">我的题解</a></td>
<td><strong>把树弱化成子数组</strong>，是一个比较好的贡献法题目。之后再考虑树的拓扑上怎么做这个事情。</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2025年11月算法好题集锦]]></title>
        <id>https://BUAA-Wander.github.io/post/2025-11-good-problems/</id>
        <link href="https://BUAA-Wander.github.io/post/2025-11-good-problems/">
        </link>
        <updated>2025-11-01T01:09:57.000Z</updated>
        <content type="html"><![CDATA[<p>Codeforces：</p>
<blockquote>
<p>gym 中题目难度分是我根据体感估计的。</p>
</blockquote>
<table>
<thead>
<tr>
<th>题目链接</th>
<th>难度分</th>
<th>Tag</th>
<th>题解</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://codeforces.com/gym/101968/problem/B">CF101968B</a></td>
<td>1700</td>
<td>画图、排序、组合数学</td>
<td></td>
<td>首先需要意识到<strong>交出来的区域是一样的</strong>，算出这个区域。然后按照这个区域去把点分成四类，只能左上配右下或者右上配左下。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/105973/problem/C">CF105973C</a></td>
<td>1700</td>
<td>数学、位运算、推式子、组合数</td>
<td></td>
<td>注意到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo>(</mo><mi>n</mi><mo separator="true">,</mo><mi>i</mi><mo>)</mo><mo>=</mo><mi>C</mi><mo>(</mo><mi>n</mi><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">C(n, i) = C(n, n - i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span>，我们如果把待求式列出来的话，可以用这个消掉大部分项，剩下的项是好维护的。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/106157/problem/F">CF106157F</a></td>
<td>2000</td>
<td>最短路</td>
<td><a href="https://github.com/Yawn-Sean/Daily_CF_Problems/blob/main/daily_problems/2025/11/1104/solution/cf106157f.md">题解</a></td>
<td>首先要注意时限为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3.5</mn><mi>s</mi></mrow><annotation encoding="application/x-tex">3.5s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">.</span><span class="mord">5</span><span class="mord mathdefault">s</span></span></span></span>，以及 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 不大。我们可以钦定从起点走到终点的最大值或者最小值中的某个，然后在符合这个约束的图上<strong>跑最大值的最小值的最短路</strong>。题解给出的是另一种从连通性的角度考虑的做法。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/105934/problem/C">CF105934C</a></td>
<td>1600</td>
<td>贪心</td>
<td><a href="https://github.com/Yawn-Sean/Daily_CF_Problems/blob/main/daily_problems/2025/11/1105/solution/cf105934c.md">题解</a></td>
<td>首先不难发现，目标数组是极大、极小、极大交替，所以其实只有两种情况，即奇数位置极大或者偶数位置极大，可以分别计算操作次数。计算时，假如枚举到当前的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">a[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 应该是极大，但现在不是，我们应该改谁最好呢？由于枚举到了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">a[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>，所以前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个肯定是已经合法了，接着我们发现 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">a[i + 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 应该是极小，所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">a[i + 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 越小越好，所以减小 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">a[i + 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 比增大 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">a[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 更能使得后边的符合题意（贪心）。所以，每遇到一个不符合题意的，就改它的下一个元素即可。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/106159/problem/D">CF106159D</a></td>
<td>1700</td>
<td>KMP、哈希、差分、测试、教学</td>
<td></td>
<td>操作不会改变模意义下的差分数组，所以本质上是对差分数组做模式匹配。请注意，本题如果要随机数据对拍，如果随机的数组长度过长+值域过大，则大概率是输出 <code>0 0</code>，<strong>属于无效对拍</strong>。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/problemset/problem/2154/D">CF2154D</a></td>
<td>1900</td>
<td>构造</td>
<td></td>
<td>首先要分析每次删的元素的性质，发现为了不暴毙，走奇数次时一定是删走偶数步才能到的点，走偶数步时删走奇数步到的点，这样能保证不会把自己给删了。此外，删除还不能导致自己被困在某个子树里，所以应该从叶子开始删。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/106177/problem/F">CF106177F</a></td>
<td>1800</td>
<td>前缀和、哈希表、两数之和</td>
<td></td>
<td><strong>两数之和复杂版</strong>。首先应该把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span> 运算分析好，然后再分析题目中的那个式子何时成立，我们先对这个式子按照奇数个数到底是奇数个还是偶数个进行讨论并展开，分析之后发现数组长度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 应该满足 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>=</mo><mn>4</mn><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">m = 4k+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的形式，并且发现题目其实就是想让这种长度的数组里奇数和偶数的个数刚好差 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。我们标记奇数为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，偶数为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>，则区间和为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 或者 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span> 是符合题意的。我们根据下标模 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 的结果，维护 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 个哈希表用来维护前缀和出现的次数，就可以做了。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/104671/problem/F">CF104671F</a></td>
<td>1700</td>
<td>位运算</td>
<td></td>
<td>我们发现 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 是预先给出来的，并且只关心与和是否等于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，所以我们其实只会选那些 <span class='katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \and at position 6: a[i] \̲a̲n̲d̲ ̲k=k'>a[i] \and k=k</span> 的数，并且最好是把区间里的这种数全都选了最有希望。其他数可以设为二进制全 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，表示选了也没用。这样就是做区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">and</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span> 的查询就好了。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/106188/problem/C">CF106188C</a></td>
<td>1700</td>
<td>DP、正难则反、教学</td>
<td></td>
<td>显然是需要用 DP 计数。我们关心的是最长的边是谁，然后需要看 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 条更短的边有多少种加起来严格大于最长边的方案。这样做的话，边长之和至多要开到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi>e</mi><mn>6</mn></mrow><annotation encoding="application/x-tex">1e6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathdefault">e</span><span class="mord">6</span></span></span></span>，再加上前两维就炸了。但是单条边长度只有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi>e</mi><mn>4</mn></mrow><annotation encoding="application/x-tex">1e4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathdefault">e</span><span class="mord">4</span></span></span></span>，所以我们其实可以计数加起来小于等于最长边的方案，相当于计数不行的，最后从所有方案 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo>(</mo><mi>n</mi><mo separator="true">,</mo><mi>k</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">C(n, k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span> 中减掉就行了。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/106189/problem/J">CF106189J</a></td>
<td>1700</td>
<td>区间DP、DP方案</td>
<td></td>
<td>首先要意识到，假如我们已经钦定删掉了某些元素，则剩下的元素的配对有点类似于剥洋葱或括号匹配，加上数据范围不大，所以启发我们使用区间DP。由于要记录方案，所以可以每个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 额外记录 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>r</mi><mi>o</mi><mi>m</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">from[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>r</mi><mi>o</mi><mi>m</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">from[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 是 DP 区间划分的中间点，最后使用一个 DFS 去把方案求出来即可。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/contest/1996/problem/G">CF1996G</a></td>
<td>2200</td>
<td>线段树、异或哈希</td>
<td></td>
<td>如果任意断掉一条边，原图就变成了树，仍然是联通的，此时任意两点的路径唯一。因此，可以考虑枚举先断掉哪条边，然后计算此时要建多少条边。我们破环为链，枚举连续的 n 个点，就是相当于在枚举断开的边。对于每个约束，会经历从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(a,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>b</mi><mo separator="true">,</mo><mi>a</mi><mo>+</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(b,a+n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 最后到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo>+</mo><mi>n</mi><mo separator="true">,</mo><mi>b</mi><mo>+</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(a+n,b+n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 这三个阶段，我们使用线段树维护这个区间加，然后查询区间中未被覆盖的个数就好了，类似扫描线。线段树里维护 min 以及 min 的个数就可以维护这个信息。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/105698/problem/G">CF105698G</a></td>
<td>1800</td>
<td>线段树、二分、mex</td>
<td></td>
<td>首先，我们应该知道，假如没有操作的左端点是 i，则查询 i 位置结果一定是 1。进一步，我们发现其实查询 i 的结果时，就是看从 i 开始往左看，看是否存在一个操作，左端点是我们正在枚举的位置，且右端点大于等于 i。其实，对于相同的 l，我们关心的是最大的 r，所以我们需要维护左端点为 l 时最大的 r。这样的话，我们相当于看每个位置最大的 l 是否大于等于 i，进一步，其实就是看一段区间里最大 r 的最小值是否大于等于 i。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/104936/problem/E">CF104936E</a></td>
<td>1800</td>
<td>字典树、双指针、前缀和</td>
<td></td>
<td>首先应该想到，求恰好等于 k 的个数有点麻烦，但是求小于等于 k 的个数是简单的，所以可以<strong>先用前缀和转化一下</strong>。接下来，我们考虑计数右端点为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> 时，有多少左端点是符合题意的。注意到右端点固定时，左端点越小，区间里的最小异或对就越小，所以符合题意的左端点一定是一个前缀。我们在考虑右端点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> 时，右端点为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 时的左端点已经算出来了，这个左端点只可能向右移动，至于移动多少，取决于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">a[r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 和哪个数异或之后 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≤</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">\le k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，所以只要区间里能有和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">a[r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 异或后 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≤</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">\le k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 的数，左端点就可以右移。使用字典树求区间的最小异或值即可。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/104536/problem/E">CF104536E</a></td>
<td>1700</td>
<td>LIS、树状数组、DP</td>
<td></td>
<td>LIS 好题。朴素做法是设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mn>0</mn><mi mathvariant="normal">/</mi><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[i][0/1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mord">/</span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 为第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个元素选 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo><mi mathvariant="normal">/</mi><mi>b</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">a[i]/b[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mord">/</span><span class="mord mathdefault">b</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 的以这个为结尾的 LIS 长度，然后只需要用两个树状数组加速 DP。更巧妙的做法是，我们由于不想让 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo><mi mathvariant="normal">/</mi><mi>b</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">a[i]/b[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mord">/</span><span class="mord mathdefault">b</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 同时被选，所以可以钦定 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">a[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">b[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 中大的放前面，小的放后面，然后直接拼成一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault">n</span></span></span></span> 的序列，这样 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">a[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">b[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 一定不会被同时选到，直接做 LIS 的 DP 就行了。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/104604/problem/D">CF104604D</a></td>
<td>1600</td>
<td>数论、分类讨论</td>
<td></td>
<td>钦定 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>≤</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \le b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>，首先应该分析出来 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>≤</mo><mi>b</mi><mo>≤</mo><mn>2</mn><mi>a</mi></mrow><annotation encoding="application/x-tex">a \le b \le 2a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault">a</span></span></span></span> 时才有解。接着考虑用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 的因数拼 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>，如果用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>，则需要检查 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mo>−</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">b - a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 是否是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 的因数；如果不用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>，则其他因数最大是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>a</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{a}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> ，最多拼成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>，只有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>=</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a = b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 时才可能行。因此，用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 的因数拼 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>，只有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>−</mo><mi>a</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(a, b - a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mclose">)</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mfrac><mi>a</mi><mn>2</mn></mfrac><mo separator="true">,</mo><mfrac><mi>a</mi><mn>2</mn></mfrac><mo>)</mo></mrow><annotation encoding="application/x-tex">(\frac{a}{2}, \frac{a}{2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.095em;vertical-align:-0.345em;"></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span> 这两种情况。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 拼 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 也是类似的，我们注意到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mo>≤</mo><mn>2</mn><mi>a</mi></mrow><annotation encoding="application/x-tex">b \le 2a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault">a</span></span></span></span>，所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>b</mi><mn>4</mn></mfrac><mo>≤</mo><mfrac><mi>a</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{b}{4} \le \frac{a}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，所以我们不可能选两个严格小于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>b</mi><mn>4</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{b}{4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 的因数，所以相当于必选 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mo separator="true">,</mo><mfrac><mi>b</mi><mn>2</mn></mfrac><mo separator="true">,</mo><mfrac><mi>b</mi><mn>3</mn></mfrac><mo separator="true">,</mo><mfrac><mi>b</mi><mn>4</mn></mfrac></mrow><annotation encoding="application/x-tex">b,\frac{b}{2},\frac{b}{3},\frac{b}{4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 中的某个数。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/106107/problem/B">CF106107B</a></td>
<td>1800</td>
<td>树状数组、离线</td>
<td></td>
<td>要计数区间个数，可以考虑枚举左端点，看有多少个右端点符合题意。什么样的右端点合法呢？首先，要包含 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>l</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">a[l]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span></span></span></span>，其次，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">a[r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 不能出现在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mo>[</mo><mi>l</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">b[l...r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 中，也就是说，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">a[r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mo>[</mo><mn>1...</mn><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">b[1...r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mopen">[</span><span class="mord">1</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 中最后一次出现位置应该 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo><mi>l</mi></mrow><annotation encoding="application/x-tex">&lt; l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>。我们可以预处理出来 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">a[r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mo>[</mo><mn>1...</mn><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">b[1...r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mopen">[</span><span class="mord">1</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 中最后一次出现的位置，记作 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>o</mi><mi>s</mi><mo>[</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">pos[r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>，则我们其实就是要查 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>o</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">pos</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span></span></span></span> 数组的后缀中有多少个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo><mi>l</mi></mrow><annotation encoding="application/x-tex">&lt; l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 的数，这个可以树状数组解决。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/contest/2106/problem/F">CF2106F</a></td>
<td>1900</td>
<td>并查集</td>
<td></td>
<td>每行其实可以看成三段，这样 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n \times n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的网格就可以看成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">3n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord mathdefault">n</span></span></span></span> 个点，然后考虑这些点中全为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 的那些，用并查集把连通的合并起来，顺带维护 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 的个数即可。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/105629/attachments">CF105629H</a></td>
<td>2000</td>
<td>数论、构造、贪心</td>
<td></td>
<td>我们考虑先构造出一个合法的拆分，然后通过调整去减小两个集合的大小之差。考虑第一个集合的 gcd 是多少，关键在于看 gcd 的素因子有谁，事实上素因子并不多，只可能是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">a[1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 的素因子中的某个，并且一个数的素因子种类数本来就只有不到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>20</mn></mrow><annotation encoding="application/x-tex">20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span></span></span></span> 个。我们枚举第一个集合的 gcd 的素因子 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>，只需要贪心地把所有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span> 的倍数加入到第一个集合中即可，因为这样才能尽可能保证第二个集合的 gcd 大于 1。之后，考虑调整，我们需要先求第二个集合的 gcd，然后枚举第二个集合的 gcd 的素因子 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span>，把第一个集合中包含素因子 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span> 的数拿到第二个集合中，去缩小二者的差距。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/problemset/gymProblem/106208/A">CF106208A</a></td>
<td>1900</td>
<td>期望、DP、对称性</td>
<td></td>
<td>首先，要意识到区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[i, j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 中随便选一个数，期望是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>i</mi><mo>+</mo><mi>j</mi></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{i + j}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.252772em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.907772em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>。进一步，要意识到，缩小区间过程中，每个区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[i, j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 都有一个在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l, r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 里的对称区间，这两个对称区间随机取一个数的期望贡献分别是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>i</mi><mo>+</mo><mi>j</mi></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{i + j}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.252772em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.907772em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>k</mi><mo>+</mo><mi>l</mi></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{k + l}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，而这两个区间出现的次数又相等，所以可以统一看成是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>l</mi><mo>+</mo><mi>r</mi></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{l + r}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 的贡献。所以，每轮缩小都可以看成贡献 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>l</mi><mo>+</mo><mi>r</mi></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{l + r}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，只要算一下期望变换轮数就好了，这个容易使用期望 DP 做。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/106015/problem/K">CF106105K</a></td>
<td>2000</td>
<td>最短路径树、最小生成树、LCA、松弛、证明</td>
<td><a href="https://github.com/Yawn-Sean/Daily_CF_Problems/blob/main/daily_problems/2025/11/1125/solution/cf106015k.md">题解</a></td>
<td>待判断是否存在的那棵树，对于每个点来说都是最短路径树，所以不难想到先求一个最短路径树，然后去判断其他边在这棵树上能否继续松弛。另一种思考是感觉每两个点之间都是最短路，那么图的总边权应该尽可能小，所以考虑最小生成树，在最小生成树上判断能否继续松弛。</td>
</tr>
</tbody>
</table>
<p>其他题目：</p>
<table>
<thead>
<tr>
<th>题目链接</th>
<th>难度分</th>
<th>Tag</th>
<th>题解</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://www.luogu.com.cn/problem/P4823">P4823</a></td>
<td>蓝</td>
<td>贪心、证明、DP、邻项交换法</td>
<td><a href="https://www.luogu.com.cn/article/99irqcre">题解</a></td>
<td>很不错的一道贪心确定决策顺序+DP求最优解的题。首先应该分析出来<strong>什么样的顺序是最优的</strong>，假设右两个人 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 目前高度都够出去，看谁先走能让后边的人够到的高度更高，这样分析即可。分析出顺序后，接下来只要按照这个顺序，看每个人走或者不走时，剩下的人梯的高度（只算肩膀）最高有多高就好了。</td>
</tr>
<tr>
<td><a href="https://www.luogu.com.cn/problem/P2224">P2224</a></td>
<td>蓝</td>
<td>DP、状态设计</td>
<td><a href="https://www.luogu.com.cn/article/99irqcre">题解</a></td>
<td>有一个显然的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>[</mo><mi>k</mi><mo>]</mo><mo>[</mo><mi>l</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[i][j][k][l]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span></span></span></span> 的四维 DP，但是第 4 维是不必要的，可以合并到前 3 维。但合并到前 3 维之后其实是求前 i 个里面，第一个机器工作 j，第二个机器工作 k 是否可行，这是一个布尔数组的 DP，很浪费，我们可以<strong>把一个维变成 DP 的结果</strong>。具体来说，我们可以只管第一个机器的工作时间 j，然后状态记最小化第二个机器的工作时间。</td>
</tr>
<tr>
<td><a href="https://www.luogu.com.cn/problem/P4158">P4158</a></td>
<td>蓝</td>
<td>背包、DP组合</td>
<td><a href="https://www.luogu.com.cn/article/99irqcre">题解</a></td>
<td>首先要读对题：问的是最多涂对的<strong>格子数</strong>，并且每个格子<strong>只能被涂 1 次</strong>，不能重复刷。基本思路就是求出每个木板被涂 <code>cnt</code> 次时至多涂对多少，然后每个木板相当于一组互斥物品，一共有 <code>n</code> 组物品做互斥背包就好了。对于内层问题，注意到涂色 <code>cnt</code> 次本质上就是涂色成了 <code>cnt</code> 段，所以只需要考察前 <code>i</code> 个格子涂成了 <code>j</code> 段的最大收益就好了。</td>
</tr>
<tr>
<td><a href="https://www.luogu.com.cn/problem/P2279">P2279</a></td>
<td>蓝</td>
<td>树形DP、状态设计</td>
<td><a href="https://www.luogu.com.cn/article/691484mg">题解</a></td>
<td>先把题目弱化为只能救火距离不超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的结点，分析明白之后就会做 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 的情况了。本题的状态设计是循序渐进的，先是发现只考虑完全覆盖的情况不够，所以多引入了一个不完全覆盖的状态，然后进一步发现按照覆盖的层数去设计状态。并且本题的状态涉及到了<strong>子树内部对外部空间的影响</strong>。</td>
</tr>
<tr>
<td><a href="https://www.luogu.com.cn/problem/P1930">P1930</a></td>
<td>蓝</td>
<td>分层图最短路、BFS、</td>
<td><a href="https://www.luogu.com.cn/article/ws9ujlr9">题解</a></td>
<td>每个格子，要么是被单独走到的，要么是被国王骑士绑定走到的，这两种走到存在区别，所以可以拆成两个点。层内都是长度为 1 的边，层间是国王走到这个点的距离作为边权。</td>
</tr>
</tbody>
</table>
<p>看到的有意思的东西：</p>
<ul>
<li><a href="https://docs.qq.com/sheet/DWFh6dWVscUZQbldo?tab=909s9n">faye教练的经验</a>，感觉和我的理念很多是一样的。</li>
<li><a href="https://www.xiaohongshu.com/explore/690ab515000000000303bc04?xsec_token=ABYE1ieUzfHO0r8MHO5DG2ezwpuwn7HAVBzwnySF0LvL8=&amp;xsec_source=pc_user">统计NOI奖牌获得者第一次获得OI奖项的时间</a></li>
<li><a href="https://www.xiaohongshu.com/explore/690ac6a70000000005010e37?xsec_token=ABuCEp6DD0fWM6jeUiZyC7YBogmWSumlwwfmadqgp4hCc=&amp;xsec_source=pc_feed">低年级实习</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/1970600336193490971">信息学竞赛统计1-学三年竞赛能取得什么成绩</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2025年10月算法好题集锦]]></title>
        <id>https://BUAA-Wander.github.io/post/2025-10-good-problems/</id>
        <link href="https://BUAA-Wander.github.io/post/2025-10-good-problems/">
        </link>
        <updated>2025-10-02T01:09:57.000Z</updated>
        <content type="html"><![CDATA[<p>Codeforces：</p>
<blockquote>
<p>gym 中题目难度分是我根据体感估计的。</p>
</blockquote>
<table>
<thead>
<tr>
<th>题目链接</th>
<th>难度分</th>
<th>Tag</th>
<th>题解</th>
<th>学到的东西</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://codeforces.com/contest/1142/problem/B">CF1142B</a></td>
<td>2000</td>
<td>倍增、破环为链</td>
<td>---</td>
<td>这是在一个<strong>结构</strong>上倍增<strong>跳步</strong>的问题，需要预处理跳若干步之后跳到了哪里。另外本题可以离线做，也可以在线做</td>
</tr>
<tr>
<td><a href="https://codeforces.com/problemset/problem/1848/F">CF1848F</a></td>
<td>2400</td>
<td>倍增、打表</td>
<td></td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo><mtext> </mtext><mo>⊕</mo><mtext> </mtext><mi>a</mi><mo>[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">a[i] = a[i]\  \oplus\ a[i + 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace"> </span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace"> </span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 这个条件在很多题中会遇到，如果所有数一起做的话，做 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>j</mi></msup></mrow><annotation encoding="application/x-tex">2^j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span></span></span></span> 轮之后会变成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo><mtext> </mtext><mo>⊕</mo><mtext> </mtext><mi>a</mi><mo>[</mo><mi>i</mi><mo>+</mo><msup><mn>2</mn><mi>j</mi></msup><mo>]</mo></mrow><annotation encoding="application/x-tex">a[i] = a[i]\  \oplus\ a[i + 2^j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace"> </span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace"> </span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0746639999999998em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>。这个规律可以通过打表找出来。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/problemset/problem/1515/E">CF1515E</a></td>
<td>2200</td>
<td>DP、组合数学</td>
<td></td>
<td>需要敏锐地发现可以按照自动打开的灯分段，然后分别计算每段自己的方案数以及和前面的段组合的方案数，这两个方案数的计算都是组合数学的典型模型。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/104679/problem/F">CF104679F</a></td>
<td>1700</td>
<td>位运算、构造</td>
<td></td>
<td>被我忽略的一个关键点在于，假如目前选的数异或出来是某个 <code>val</code>，则其和目标值 <code>target</code> 之间<strong>仅差一步就可以转化过去</strong>。异或的这个特点在其他题里也会遇到，经常用于前面若干个随便选，只用最后一个来调整结果。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/104679/problem/E">CF104679E</a></td>
<td>1600</td>
<td>数论</td>
<td></td>
<td>又是一道数论与图论结合的题目，值得注意的点在于本题输入一个数输出一个数，并且有很显然的暴力做法， 所以完全可以本地对拍过之后再提交。本题恰好在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 比较小的时候比较特殊，对拍能找到问题。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/104822/problem/I">CF104822I</a></td>
<td>1900</td>
<td>数论</td>
<td></td>
<td>首先要把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(a + b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span> 整除 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">ab</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span></span></span></span> 转化为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(a + b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span> 整除 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">a^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>，这样转化的目的是有一边固定下来了。后边涉及到<strong>素因数分解之后反求出约数</strong>，这个只需要设一个约数集合 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>=</mo><mo>{</mo><mn>1</mn><mo>}</mo></mrow><annotation encoding="application/x-tex">S = \{1\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">1</span><span class="mclose">}</span></span></span></span>，然后枚举素因数及其次数，和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> 中已有的乘起来，每完成一个素因数的计算就把新得到的因数加到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> 中。这样复杂度是不高的，因为约数个数本身也就小几百个，而我们每次计算必然会增加一个新的之前没得到的约数。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/104328/problem/D">CF104328D</a></td>
<td>1800</td>
<td>数论、树形DP</td>
<td></td>
<td>本质上是求树的满足一定性质的<strong>直径</strong>，可以枚举直径的最高点，然后枚举直径中应该包含的素因子是谁，去做 DP 即可。这里需要注意<strong>一个数的素因子种类数并不多</strong>，常见的数据范围内也就 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span> 个左右。还需要注意一个点就是快速素因数分解的复杂度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>log</mi><mo>⁡</mo><mi>M</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\log M)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span>，也是比较快的，因此这个题才可以这样做。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/104380/problem/F">CF104380F</a></td>
<td>1600</td>
<td>构造、贪心、堆</td>
<td></td>
<td>首先要敏锐的观察到，往 deque 中插数据时，最后一个数要么在做最左边，要么在最右边，所以做不到无脑把最大的那些数放到想要的位置。然后会想到假如钦定不要某个后缀被选了，能否让剩下的前缀取到理论上的最大值，发现只要枚举后缀，然后看前缀往左还是往右放就好了。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/105486/problem/I">CF105485I</a></td>
<td>1800</td>
<td>数论、线段树</td>
<td></td>
<td>当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>gcd</mi><mo>⁡</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\gcd = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mop"><span style="margin-right:0.01389em;">g</span>cd</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 时，答案应该输出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，这个点被我疏忽了，之后通过对拍和猜测这两种方式分别找到了 bug。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/103855/problem/D">CF103855D</a></td>
<td>1800</td>
<td>分类讨论、贪心</td>
<td></td>
<td>最开始想了一个<strong>错误的贪心</strong>，但还好写之前就自己构造数据 hack 了自己。然后发现其实本质上就是拿 0 和 3 以及拿 1 和 2 这两类情况，只要分类讨论就好了，这时<strong>又想了一个错误的贪心</strong>（1 拿最大的），但也反应过来不对了，发现还是得枚举 1 到底拿谁。还是要多造数据去验证想法的正确性。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/102409/problem/J">CF102409J</a></td>
<td>1600</td>
<td>枚举、贪心、证明</td>
<td></td>
<td>可以想到多种枚举方式。枚举第一个分割点后贪心正确性存疑，枚举第二个点后左右评分容易证明正确性。另外可以快速写一个对拍验证正确性。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/102419/problem/D">CF102419D</a></td>
<td>1800</td>
<td>二分图判定、测试、教学</td>
<td></td>
<td><strong>一道用于说明随机数据测试并非万能的好题</strong>！由于这道题目的特殊性，我们可以本地验证答案是否正确，就容易想到随机生成数据去测，测完再提交。但一方面，这个题多一个 <code>log</code> 是过不去的，本地小数据测不出来（TLE）；另一方面，本题的值域严格卡到了 <code>1 &lt;&lt; 20</code>，如果只开 <code>1e6</code> 是过不了的（RE）。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/contest/691/problem/E">CF691E</a></td>
<td>1900</td>
<td>矩阵快速幂、DP、教学</td>
<td></td>
<td>入门题，以后讲课可以扔到例题里。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/problemset/problem/1117/D">CF1117D</a></td>
<td>2100</td>
<td>矩阵快速幂、DP、教学</td>
<td></td>
<td>更入门的矩阵快速幂。注意计算方案数的题目要同时看一下 DP 和组合数学方法，都去试一试。组合数学方法不好算时，说不定 DP 能快速幂优化解决。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/104848/problem/M">CF104848M</a></td>
<td>1900+</td>
<td>柯西不等式、最短路、教学</td>
<td><a href="https://github.com/Yawn-Sean/Daily_CF_Problems/blob/main/daily_problems/2025/10/1018/solution/cf104848m.md">题解</a></td>
<td>可以弱化成链上的问题，用来吸引学数学竞赛的人来搞 OI。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/105408/problem/G">CF105408G</a></td>
<td>1500</td>
<td>数论、教学、测试</td>
<td></td>
<td>本题是一个很好的说明<strong>随机数据可能测不全</strong>的例子，因为想随机出两两 GCD 一样的数组，在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 稍微大一点或者值域稍微大一点时很困难。另外，本题在 YES 的情况时，时间复杂度会卡满，本地随机测试几乎测不到这种情况，这时需要先生成一个 gcd，然后选一堆素数和其相乘，就可以构造出一个 YES 的情况。实测某些看似能过的做法会在 YES 的时候 TLE 掉。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/problemset/gymProblem/103886/G">CF103886G</a></td>
<td>1800</td>
<td>分治、构造</td>
<td></td>
<td><strong>按二进制位分治</strong>。如果把奇数放左边，偶数放右边，则不可能存在题中所说的跨左右两段的三元组，从而只需要分别考虑左右两边，递归下去，只要再按照更高的二进制位进行分类即可。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/105335/problem/I">CF105335I</a></td>
<td>2000</td>
<td>康托展开、树状数组二分、教学</td>
<td><a href="https://github.com/Yawn-Sean/Daily_CF_Problems/blob/main/daily_problems/2025/10/1021/solution/cf105335i.md">题解</a></td>
<td>首先要知道咋算一个排列的排名，然后需要把后边那个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>n</mi><mo>!</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{n!}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mclose mtight">!</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 合并到前面的项中，从而也转化成“<strong>每个数在后缀中排名多少</strong>”这个信息，只要有了这个信息，使用一个有序结构从左到右搞一搞就可以构造出排列了。注意，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>n</mi><mo>!</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{n!}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mclose mtight">!</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 这种极大的数很难直接用除法算排名，所以只能像上面那样搞排名。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/105582/problem/C">CF105582C</a></td>
<td>1800</td>
<td>DP、二分、多重背包、优化教学</td>
<td></td>
<td>首先容易想到一个裸的 DP 去看凑出质量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 的集合至多多少个，但是这个 DP 的状态不太能优化。考虑到答案有单调性，可以二分。二分之后，我们相当于限定了一个集合中每种零件至多用多少个，这样就成了裸的多重背包问题。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/106125/problem/E">CF106125E</a></td>
<td>1600</td>
<td>随机、乱搞、骗分、教学</td>
<td><a href="https://github.com/Yawn-Sean/Daily_CF_Problems/blob/main/daily_problems/2025/10/1025/solution/cf106125e.md">题解</a></td>
<td>练习一下乱搞。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/106125/problem/F">CF106125F</a></td>
<td>2100</td>
<td>补图、二分图、DP、测试、教学</td>
<td></td>
<td>容易发现 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 比较小的时候才有解，这个时候图非常稠密，接近一个完全图。考虑两个点是否在一个集合是困难的，但是两个点不在同一个集合这个事情似乎是容易做的。考虑补图，补图上的边代表互斥关系，则补图是二分图时必有点没法放到任何一个集合里。另外由于要求两个集合一样大，所以需要 DP 求具体方案。本题可以本地写 spj 测试，数据生成的时候建议生成点数少且边数多的图，或从完全图上删少量的边，<strong>纯随机数据测会不可以总司令</strong>。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/contest/703/problem/D">CF703D</a></td>
<td>2100</td>
<td>离线、树状数组</td>
<td></td>
<td>首先区间异或和是可以前缀异或和求出来的，然后区间中出现偶数次的数是不贡献到区间异或和里的，进而发现<strong>区间异或和就是区间中出现奇数次的数的异或和</strong>（无需去重）。区间中所有数字去重的异或和，再异或上出现奇数次的数的异或和，就是偶数次的数去重的异或和了。<strong>所有数去重的异或和</strong>可以类比<strong>区间中不同数的个数</strong>的做法（HH 的项链）去维护。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/problemset/problem/2001/D">CF2001D</a></td>
<td>1900</td>
<td>线段树、单调栈、树状数组、双指针、测试、教学</td>
<td><a href="https://docs.qq.com/sheet/DWGFoRGVZRmxNaXFz?tab=BB08J2">题解</a></td>
<td>本题如果使用一种错误的单调队列写法，<strong>本地对拍测试时有可能需要 1 分钟左右才能拍出 bug</strong>，这个错误做法提交后也能通过多测的 4 组测试点，算是比较隐蔽的 bug 了。使用线段树实现查询是正确的，但是比较长。小清新做法是使用单调栈，灵神最喜欢的数据结构。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/104901/problem/K">CF104901K</a></td>
<td>2100</td>
<td>树状数组、中位数贪心、双指针、二分</td>
<td></td>
<td><strong>一段数组每个比上一个大 1，则每个数减掉自己的下标之后应该相等</strong>，这是个比较经典的套路。我们相当于想让一段 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>−</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">a[i] - i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 相等，这个使用绝对值不等式可知最小操作次数就是改成中位数。求中位数可以树状数组二分去做。如何计算代价呢？只要分别维护比中位数小的数的和，以及更大的数的和就好了。如果外边套二分答案则是双 log，过不去，需要把二分答案改成双指针。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/problemset/gymProblem/106054/B">CF106054B</a></td>
<td>2000</td>
<td>组合数学、隔板法</td>
<td></td>
<td>根据 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 数组，可以求出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 中相隔 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 项的两个数之间的差的关系，只要确定了前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 个数，后边的就都确定了，关键是根据这个关系算出来前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 个数的下界，然后就是隔板法计算了。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/problemset/problem/134/B">CF134B</a></td>
<td>1900</td>
<td>辗转相除法、数论、教学</td>
<td></td>
<td>考辗转相除法求 gcd 的过程的题目。反着来看，看 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>n</mi><mo separator="true">,</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(n, x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 如何变成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(1, 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，题目所给的这个过程就类似于求 gcd 的过程，能变成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(1, 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 说明两个数得互素，在求 gcd 的过程中顺便统计一下操作次数就好了。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/104785/problem/K">CF104785K</a></td>
<td>1700</td>
<td>图论、脑筋急转弯</td>
<td></td>
<td>选一些边，则选择的边构成的集合和剩下的边构成的集合，至少有一个的大小是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>m</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{m}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，所以我们可以想办法将边分成这两类，每类内部都无环，则总有一个是符合题意的。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/problemset/problem/2129/B">CF2129B</a></td>
<td>1600</td>
<td>逆序对</td>
<td></td>
<td>首先要知道 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>n</mi><mo>−</mo><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>≥</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">2n - p[i] \ge n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>。倘若我们按 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">p[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 从小到大的顺序去考虑变还是不变，如果不变，则其他所有还没填的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">p[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 变或者不变都一定比 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">p[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 大，所以只要考虑左边还没填的贡献答案就好；如果变了，则其他所有还没填的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">p[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 不管变还是不变，都一定比 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>n</mi><mo>−</mo><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">2n - p[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 小，所以只要考虑右边的就好了。这样相当于考虑 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">p[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 和还没填的数构成的逆序数，<strong>把逆序数记到先填的数头上</strong>，就不重不漏了，且可以独立考虑，就容易做了。</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/106144/problem/F">CF106144F</a></td>
<td>1600</td>
<td>博弈、测试</td>
<td></td>
<td>根据博弈论最基本的判断先手必胜还是必败的原理，我们可以写一个 DP。这个题数据范围比较大，DP 只能做一小部分，但是能辅助我们检查猜测的结论是否正确，对拍一下就知道了。</td>
</tr>
</tbody>
</table>
<p>其他题目：</p>
<table>
<thead>
<tr>
<th>题目链接</th>
<th>难度分</th>
<th>Tag</th>
<th>题解</th>
<th>学到的东西</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://www.luogu.com.cn/problem/P12247">P12247</a></td>
<td>上位绿</td>
<td>扫描线、堆、DP</td>
<td><a href="https://www.luogu.com.cn/problem/solution/P12247">P12247</a></td>
<td>一道很综合的题目，首先要想到在<strong>时间轴</strong>上去 DP，写出朴素的转移方程，然后发现需要一个查询最大值的结构，且需要排除过期元素，用扫描线的思想+懒删除实现过期删除，也可以使用 <code>multiset</code> 直接实现随机删除和查询最大值，常数可能会大一点。</td>
</tr>
<tr>
<td><a href="https://www.luogu.com.cn/problem/T673603">T673603</a></td>
<td>上位绿</td>
<td>逆序对、树状数组、贡献法</td>
<td><a href="https://www.luogu.com.cn/paste/yz58xx5w">题解+std</a></td>
<td><strong>邻项交换次数</strong>和<strong>逆序对</strong>关联很大，所以首先要想到这个事情。第二个事情，重排得到山脉数组可以看成是从小到大考虑所有数，每次塞到左边或者右边。第三个事情，由于交换次数就是求逆序对，所以我们考虑每个数字头上有多少次交换（即多少逆序数），为了不重不漏可以钦定把贡献<strong>记到小的数头上</strong>。</td>
</tr>
<tr>
<td><a href="https://www.luogu.com.cn/problem/P7113">P7113</a></td>
<td>黄</td>
<td>拓扑排序、<code>__int128_t</code></td>
<td></td>
<td>学一下怎么用 <code>__int128_t</code>，本题不用这个过不了（怪题），以及手写分数结构体及其操作。并且需要注意 <code>__int128_t</code> 需要模拟<strong>逐位输出</strong>，不要在关闭流同步时<strong>混用输出方式</strong>。</td>
</tr>
<tr>
<td><a href="https://www.luogu.com.cn/problem/P2536">P2536</a></td>
<td>绿</td>
<td>DP</td>
<td></td>
<td>注意 DP 初始化，本题中所有的 <code>dp[i][0]</code> 和 <code>dp[0][j]</code> 都需要初始化。写 DP 时要检查每个值的前序值是否真的都算过/初始化过了。</td>
</tr>
<tr>
<td><a href="https://www.luogu.com.cn/problem/P4768">P4768</a></td>
<td>紫</td>
<td>kruskal重构树、倍增、最短路、强制在线</td>
<td></td>
<td>学习了kruskal重构树的模板以及应用，并深深体会到了<strong>强制在线对题目难度的巨大影响</strong>。以及，多组数据一定要检查是不是清空了！这个题涉及到的数据很多，做的时候<strong>多测没有完全清空</strong>，使用 <code>memset</code> 二分清空才发现到底是哪个东西忘了清了。</td>
</tr>
<tr>
<td><a href="https://www.luogu.com.cn/problem/T673604">T673604</a></td>
<td>蓝</td>
<td>分治、按位贪心、Trie</td>
<td><a href="https://www.luogu.com.cn/paste/yz58xx5w">题解+std</a></td>
<td>题目给出了正着构造的规则，但要求倒退回去有多少可能的来源，这需要我们先分析正着构造的性质。</td>
</tr>
<tr>
<td><a href="https://www.luogu.com.cn/problem/P4059">P4059</a></td>
<td>上位绿</td>
<td>DP、转化、初始化</td>
<td></td>
<td>首先这个题目要注意到连续空格的贡献是一次函数，倘若只是正比例函数那么相当于每个空格贡献是<strong>常数</strong>，一次函数的话只是第一次比较特殊，后边的贡献都一样。第二个要注意的点在于<strong>初始化</strong>，本题的初始化比较麻烦，需要分析好。</td>
</tr>
<tr>
<td><a href="https://atcoder.jp/contests/abc180/tasks/abc180_e">ABC180E</a></td>
<td>绿</td>
<td>状压DP、证明</td>
<td></td>
<td>本题值得学习的点在于证明每个点只需要走恰好一次，证明的关键是发现两点之间的距离函数满足三角形不等式，所以任何重复访问都是不优的。</td>
</tr>
<tr>
<td><a href="https://www.luogu.com.cn/problem/P4926">P4926</a></td>
<td>蓝</td>
<td>差分约束</td>
<td></td>
<td>建模细节非常多的一个题。首先二分答案是显然的；然后需要把乘法约束取对数变成加法约束，才能转化成差分约束，这样会导致二分上界受到第一种承诺的约束；接着，初值点需要使用超级源点建立等式约束，没给初值的点也需要加入单向 0 边保证能遍历到，这样才能把所有约束都考虑进来。</td>
</tr>
<tr>
<td><a href="https://www.luogu.com.cn/problem/T676142">T676142</a></td>
<td>绿</td>
<td>DP、组合数学、测试</td>
<td></td>
<td>赛时对拍都过了，思路也很流畅，最后挂了 30 分，原因是有个地方取模没取上，而<strong>对拍只拍了小数据</strong>，还是赖自己没有仔细检查溢出的情况（取模也是一种溢出），太可惜了。</td>
</tr>
<tr>
<td><a href="https://www.luogu.com.cn/problem/P1939">P1939</a></td>
<td>绿</td>
<td>矩阵快速幂</td>
<td></td>
<td>其实是一个模板题，但是这里我才算是第一次知道<strong>咋写转移矩阵</strong>。我们注意到递推公式里包含 3 个数，于是我们考虑怎么从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>−</mo><mn>3</mn></mrow></msub><mo separator="true">,</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>−</mo><mn>2</mn></mrow></msub><mo separator="true">,</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(a_{i - 3}, a_{i - 2}, a_{i - 1})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 转移到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>−</mo><mn>2</mn></mrow></msub><mo separator="true">,</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>a</mi><mi>i</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(a_{i - 2}, a_{i - 1}, a_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，考虑给第一个列向量左乘一个矩阵得到第二个向量，那么根据待定系数法 + 对应项相等，就知道了这个转移矩阵的具体值。</td>
</tr>
<tr>
<td><a href="https://www.luogu.com.cn/problem/P10499">P10499</a></td>
<td>蓝</td>
<td>高斯消元</td>
<td></td>
<td>主要是<strong>问题建模</strong>。我们考虑对于第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个开关，主动按哪些开关时会让这个开关的状态也变化。这样的话，假如我们知道每个开关到底按没按，只需要把这两个东西做一个对应位置的与操作，再把与的结果异或起来（类似内积先乘后加），就是最终经过这些操作后到底改没改变这个开关的状态了。</td>
</tr>
<tr>
<td><a href="https://www.luogu.com.cn/problem/T676143">T676143</a></td>
<td>蓝</td>
<td>ST表、括号序列、哈希、二分</td>
<td></td>
<td>积累了两个技巧：第一个是左右括号数量相等的括号序列<strong>仅通过循环移位</strong>就可以使之合法，第二个是比较一个字符串的两个子串的字典序，可以用<strong>哈希+二分</strong>求出这两个子串第一个不一样的位置，然后比较这个位置的字符，这样无需暴力比较了。</td>
</tr>
<tr>
<td><a href="https://www.luogu.com.cn/problem/P9043">P9043</a></td>
<td>绿</td>
<td>复杂键哈希、双指针、分类讨论、推式子</td>
<td></td>
<td>一种和两种字符的情况有很多办法可以做，关键是如何解决三种字符的情况。三个相等其实可以转化成两对两个相等，例如 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi><mo>[</mo><mi>r</mi><mo>]</mo><mo>[</mo><mi>a</mi><mo>]</mo><mo>−</mo><mi>c</mi><mi>n</mi><mi>t</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>a</mi><mo>]</mo><mo>=</mo><mi>c</mi><mi>n</mi><mi>t</mi><mo>[</mo><mi>r</mi><mo>]</mo><mo>[</mo><mi>b</mi><mo>]</mo><mo>−</mo><mi>c</mi><mi>n</mi><mi>t</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>b</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">cnt[r][a] - cnt[l][a] = cnt[r][b] - cnt[l][b]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">b</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">b</span><span class="mclose">]</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi><mo>[</mo><mi>r</mi><mo>]</mo><mo>[</mo><mi>b</mi><mo>]</mo><mo>−</mo><mi>c</mi><mi>n</mi><mi>t</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>b</mi><mo>]</mo><mo>=</mo><mi>c</mi><mi>n</mi><mi>t</mi><mo>[</mo><mi>r</mi><mo>]</mo><mo>[</mo><mi>c</mi><mo>]</mo><mo>−</mo><mi>c</mi><mi>n</mi><mi>t</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>c</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">cnt[r][b] - cnt[l][b] = cnt[r][c] - cnt[l][c]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">b</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">b</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">c</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">c</span><span class="mclose">]</span></span></span></span>，变形成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi><mo>[</mo><mi>r</mi><mo>]</mo><mo>[</mo><mi>a</mi><mo>]</mo><mo>−</mo><mi>c</mi><mi>n</mi><mi>t</mi><mo>[</mo><mi>r</mi><mo>]</mo><mo>[</mo><mi>b</mi><mo>]</mo><mo>=</mo><mi>c</mi><mi>n</mi><mi>t</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>a</mi><mo>]</mo><mo>−</mo><mi>c</mi><mi>n</mi><mi>t</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>b</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">cnt[r][a] - cnt[r][b] = cnt[l][a] - cnt[l][b]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">b</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">b</span><span class="mclose">]</span></span></span></span>，然后发现可以维护 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>c</mi><mi>n</mi><mi>t</mi><mo>[</mo><mi>a</mi><mo>]</mo><mo>−</mo><mi>c</mi><mi>n</mi><mi>t</mi><mo>[</mo><mi>b</mi><mo>]</mo><mo separator="true">,</mo><mi>c</mi><mi>n</mi><mi>t</mi><mo>[</mo><mi>b</mi><mo>]</mo><mo>−</mo><mi>c</mi><mi>n</mi><mi>t</mi><mo>[</mo><mi>c</mi><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">(cnt[a] - cnt[b], cnt[b] - cnt[c])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">b</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">b</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">c</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span> 的二元组的个数就好了，只要两个二元组相等，就说明这个串是可以的。</td>
</tr>
<tr>
<td><a href="https://www.luogu.com.cn/problem/P8806">P8806</a></td>
<td>绿</td>
<td>DP、贪心、证明、骗分、教学</td>
<td></td>
<td>证明为什么按照 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mo>+</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">w + v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span> 排序，以及如果没有证明出来，有什么骗分的办法，以及如何检测（对拍）。</td>
</tr>
<tr>
<td><a href="https://www.luogu.com.cn/problem/P8817">P8817</a></td>
<td>蓝</td>
<td>BFS、暴力、测试</td>
<td></td>
<td>本题对拍时测出来设置的无穷大不够大，因为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 有可能超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 很小但 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 比较大时，设置最短路为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 就会有问题。另外本题在做的时候中间一次关键的代码修改导致复杂度变成了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>3</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，需要进一步优化才能通过本题。</td>
</tr>
</tbody>
</table>
<p>看到的有意思的东西：</p>
<ul>
<li><a href="https://www.xiaohongshu.com/explore/68cd977d000000001300e55e?xsec_token=ABYfpW1DPd3BQZ8r26rPygSxPPYgk9hDxTbQOjSid_O_E=&amp;xsec_source=pc_user">ICPC常用组合数公式与技巧 - 小红书</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/494875993">代码源每日一题 Div1 括号序列 - 知乎</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2025年9月算法好题集锦]]></title>
        <id>https://BUAA-Wander.github.io/post/2025-09-good-problems/</id>
        <link href="https://BUAA-Wander.github.io/post/2025-09-good-problems/">
        </link>
        <updated>2025-09-01T01:27:22.000Z</updated>
        <content type="html"><![CDATA[<p>Codeforces：</p>
<blockquote>
<p>*表示对 gym 中题目难度的估计。</p>
</blockquote>
<table>
<thead>
<tr>
<th>题目链接</th>
<th>难度分</th>
<th>Tag</th>
<th>题解</th>
<th>学到的东西</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://codeforces.com/contest/1900/problem/D">CF1900D</a></td>
<td>2000</td>
<td>数论、容斥</td>
<td>---</td>
<td>学习去掉倍数的重复情况</td>
</tr>
<tr>
<td><a href="https://codeforces.com/contest/141/problem/D">CF141D</a></td>
<td>2300</td>
<td>DP、最短路</td>
<td>---</td>
<td>从要求的结果来看，这是一个求最短路的问题，但又可以用DP去做。真正操作起来，发现真用DP做起来转移比较麻烦（涉及到往回走），所以可以考虑直接建图跑最短路算法</td>
</tr>
<tr>
<td><a href="https://codeforces.com/contest/164/problem/A">CF164A</a></td>
<td>1700</td>
<td>两遍DFS</td>
<td>---</td>
<td>图论题容易想当然，在可能有环的图上执行一个算法时，需要多造一些包含环的样例，并模拟一些不同的DFS顺序</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/102861/problem/I">CF102861I</a></td>
<td>1800</td>
<td>树形DP、乘法逆元、前后缀分解</td>
<td>---</td>
<td>正确做法是前后缀分解去维护子树的乘积，如果用乘法逆元的话，可能会遇到dp值为0的问题。我们脑子里仍然要把乘法逆元认为是除法，这样就不会忘记0没有逆元这个事实</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/105862/problem/H">CF105862H</a></td>
<td>1800</td>
<td>期望、贡献法</td>
<td>---</td>
<td>首先要发现每个数的贡献次数是一样的，只需要算某一个数的贡献次数，然后在求贡献次数时，可以考虑枚举 step，看有多少个合法的 current，current 的数量其实就是形成的循环中的位置个数（关键转化），所以变成了求每次走 step 步形成的环有多大</td>
</tr>
<tr>
<td><a href="https://codeforces.com/contest/2148/problem/F">CF2148F</a></td>
<td>1800</td>
<td>贪心、根号结论</td>
<td><a href="https://codeforces.com/blog/entry/146112">官方题解</a></td>
<td>对于一个数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，将其拆成若干个正整数相加的形式，则在一个拆分中至多能拆出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msqrt><mi>n</mi></msqrt><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\sqrt{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.05028em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">n</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 种不同的数。使用这个结论可以知道复杂度是对的</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/105387/problem/G">CF105387G</a></td>
<td>1800</td>
<td>DP、前缀和、取模易错点</td>
<td></td>
<td>题目中涉及到取模后做减法，所以最后计算出的结果有可能是负数，需要调整成正数后输出</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/104777/problem/N">CF104777N</a></td>
<td>1800</td>
<td>字典树</td>
<td></td>
<td>首先要能分析出来前缀异或和互不相同才可能有解，然后注意到由于已经互不相同了，所以不管怎么异或都是互不相同，所以选定一个数之后我们关键是验证其能不能让最大值恰好为 n - 1，这就需要 01 Trie 来做了</td>
</tr>
<tr>
<td><a href="https://codeforces.com/contest/2149/problem/E">CF2149E</a></td>
<td>1600</td>
<td>双指针、前缀和思想</td>
<td></td>
<td>这题是个前缀和套娃题，首先我们应该知道，假如不限制长度的话，我们会用双指针求不超过 k 种数的区间数，进一步，限制长度的话，如果只是限制上限，那么这个事情也是简单的，进而我们发现可以用前缀和的思想把下限的情况也解决了；然后考虑恰好 k 种，其实就是不超过 k 种减去不超过 k - 1 种的区间数</td>
</tr>
<tr>
<td><a href="https://codeforces.com/contest/1487/problem/E">CF1487E</a></td>
<td>2000</td>
<td>枚举，mex</td>
<td></td>
<td>有多个变量互相牵制且都需要枚举，需要考虑枚举哪个，才能让另外的可以少枚举或者预处理即可得到结果</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/100488/problem/I">CF100488I</a></td>
<td>1600</td>
<td>并查集、补图</td>
<td></td>
<td>首先发现这道题是说的当且仅当，也就是说不相邻的点必须有相同颜色，所以容易想到补图中同一个连通块里的点的颜色必须相同，然后用原图的边检查是否冲突即可</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/100488/problem/K">CF100488K</a></td>
<td>1800</td>
<td>反悔贪心</td>
<td></td>
<td>首先不难分析出来，前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个里面至多拿 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{i + 1}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.200664em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.855664em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 个，考虑前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个里自己能拿多少钱的，要么发现自己能多拿一个，要么发现需要和之前某个最便宜的换，换总是不会违反拿的个数约束的</td>
</tr>
<tr>
<td><a href="https://codeforces.com/problemset/problem/865/D">CF865D</a></td>
<td>2400</td>
<td>反悔贪心</td>
<td></td>
<td>反悔贪心问题中，我们想的贪心可以傻瓜得不行，因为关键在于怎么反悔，只要保证反悔之后是最优的就好了</td>
</tr>
</tbody>
</table>
<p>AtCoder：</p>
<p>其他题目：</p>
<table>
<thead>
<tr>
<th>题目链接</th>
<th>难度</th>
<th>Tag</th>
<th>题解</th>
<th>学到的东西</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://www.luogu.com.cn/problem/P5676">洛谷P5676</a></td>
<td>绿</td>
<td>强连通分量</td>
<td>---</td>
<td>边界情况判错了，当本题的有趣度是自己的兴奋度的倍数时，可以循环做本题，而不是相等，如果判错了会丢掉 40 分！另外如果没有样例提示能单点成环也算的话，可能会直接得 0 分！</td>
</tr>
<tr>
<td><a href="https://ac.nowcoder.com/acm/contest/116658/F">牛客周赛108F</a></td>
<td>2000分</td>
<td>位运算、SOSDP、超集枚举</td>
<td>---</td>
<td>一个新知识点，要求某个数所有超集的某个值，无需枚举其所有超集，只需要枚举比其多一个set位的集合即可</td>
</tr>
<tr>
<td><a href="https://www.luogu.com.cn/problem/P4832">洛谷P4832</a></td>
<td>绿</td>
<td>带偏移量的DP、滚动数组</td>
<td>---</td>
<td>复习了一下这两个东西，有段时间没遇到了</td>
</tr>
<tr>
<td><a href="https://ac.nowcoder.com/acm/contest/116945/F">牛客周赛109F</a></td>
<td>1800分</td>
<td>推式子、离散化、树状数组、离线</td>
<td>---</td>
<td>利用条件，发现要求的是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mi>i</mi></msub><mo>≤</mo><mi>min</mi><mo>⁡</mo><mo>(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>+</mo><msub><mi>k</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>−</mo><msub><mi>x</mi><mi>i</mi></msub><mo>+</mo><msub><mi>k</mi><mn>2</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">y_i \le \min(x_i + k_1, -x_i + k_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 的个数，不难想到讨论两个东西在什么情况下最小，然后就可以把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>min</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\min</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66786em;vertical-align:0em;"></span><span class="mop">min</span></span></span></span> 去掉求解了</td>
</tr>
</tbody>
</table>
<p>看到的有意思的东西：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/1945782212176909162">每次删除两个不同的数，至多删除多少次</a></li>
<li><a href="https://www.zhihu.com/question/1936769453896501072">&quot;保证数据随机&quot;到底隐含了什么</a></li>
<li><a href="https://github.com/2754LM/oj_helper">OJ helper</a>，可以查所有平台的总题量。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSP-S知识点备忘录]]></title>
        <id>https://BUAA-Wander.github.io/post/csp-s-checklist/</id>
        <link href="https://BUAA-Wander.github.io/post/csp-s-checklist/">
        </link>
        <updated>2025-08-26T08:16:06.000Z</updated>
        <content type="html"><![CDATA[<p>最近在备考 CSP-S，看到 B 站<a href="https://space.bilibili.com/443688461">某竞赛教练</a>有说到要拿省一需要补齐短板，检查自己每个知识点到底能会做什么难度的题目。考虑到自己最近一年多一直在随机刷题，虽然颇有进步，但是确实不太清楚自己每个知识点的具体掌握情况。稍微浏览了教练提供的 <a href="https://docs.qq.com/sheet/DWFh6dWVscUZQbldo?tab=bv34hm">checklist</a> 之后，意外的发现一些东西有点忘了，甚至有极个别的知识点我还不会（例如割点割边、树的重心等）。因此，我准备做一个备忘录，把自己已经忘掉的 CSP-J/S 组知识点做下总结，补齐短板，希望能够在复赛稳定打出一个满意的成绩，不要因为知识点忘了而丢分。</p>
<p>本备忘录优先记录有所遗忘的知识点，如有时间，会对重点考点的重要技巧再进行一些总结。</p>
<h2 id="时间复杂度计算">时间复杂度计算</h2>
<p>初赛里的题目主要是考主定理，对于下面的式子：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>a</mi><mi>T</mi><mo>(</mo><mfrac><mi>n</mi><mi>b</mi></mfrac><mo>)</mo><mo>+</mo><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">T(n) = aT(\frac{n}{b}) + f(n)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.7935600000000003em;vertical-align:-0.686em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">b</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span></p>
<p>当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><msup><mi>n</mi><mrow><msub><mi>log</mi><mo>⁡</mo><mi>b</mi></msub><mi>a</mi><mo>−</mo><mi>ϵ</mi></mrow></msup><mo>)</mo><mo separator="true">,</mo><mi>ϵ</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f(n) = O(n^{\log_ba - \epsilon}), \epsilon &gt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mop mtight">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.23015999999999992em;"><span style="top:-2.2341314285714287em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.26586857142857145em;"><span></span></span></span></span></span></span><span class="mspace mtight" style="margin-right:0.19516666666666668em;"></span><span class="mord mathdefault mtight">a</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">ϵ</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">ϵ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 时，有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi mathvariant="normal">Θ</mi><mo>(</mo><msup><mi>n</mi><mrow><msub><mi>log</mi><mo>⁡</mo><mi>b</mi></msub><mi>a</mi></mrow></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">T(n) = \Theta(n^{\log_ba})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mop mtight">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.23015999999999992em;"><span style="top:-2.2341314285714287em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.26586857142857145em;"><span></span></span></span></span></span></span><span class="mspace mtight" style="margin-right:0.19516666666666668em;"></span><span class="mord mathdefault mtight">a</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，例如 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mn>2</mn><mi>T</mi><mo>(</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo>)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">T(n) = 2T(\frac{n}{2}) + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.095em;vertical-align:-0.345em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，复杂度就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\Theta(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p>
<p>当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi mathvariant="normal">Ω</mi><mo>(</mo><msup><mi>n</mi><mrow><msub><mi>log</mi><mo>⁡</mo><mi>b</mi></msub><mi>a</mi><mo>+</mo><mi>ϵ</mi></mrow></msup><mo>)</mo><mo separator="true">,</mo><mi>ϵ</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f(n) = \Omega(n^{\log_ba + \epsilon}), \epsilon &gt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mord">Ω</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mop mtight">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.23015999999999992em;"><span style="top:-2.2341314285714287em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.26586857142857145em;"><span></span></span></span></span></span></span><span class="mspace mtight" style="margin-right:0.19516666666666668em;"></span><span class="mord mathdefault mtight">a</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">ϵ</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">ϵ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 时，有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi mathvariant="normal">Θ</mi><mo>(</mo><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">T(n) = \Theta(f(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，直观理解就是对分治的结果进行合并时，合并代价太大了，以至于复杂度由合并复杂度主导。</p>
<p>当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi mathvariant="normal">Θ</mi><mo>(</mo><msup><mi>n</mi><mrow><msub><mi>log</mi><mo>⁡</mo><mi>b</mi></msub><mi>a</mi></mrow></msup><msup><mi>log</mi><mo>⁡</mo><mi>k</mi></msup><mi>n</mi><mo>)</mo><mo separator="true">,</mo><mi>k</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f(n) = \Theta(n^{\log_ba}\log^kn), k \ge 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1834479999999998em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mop mtight">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.23015999999999992em;"><span style="top:-2.2341314285714287em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.26586857142857145em;"><span></span></span></span></span></span></span><span class="mspace mtight" style="margin-right:0.19516666666666668em;"></span><span class="mord mathdefault mtight">a</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9334479999999998em;"><span style="top:-3.1473400000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 时，有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi mathvariant="normal">Θ</mi><mo>(</mo><msup><mi>n</mi><mrow><msub><mi>log</mi><mo>⁡</mo><mi>b</mi></msub><mi>a</mi></mrow></msup><msup><mi>log</mi><mo>⁡</mo><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msup><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">T(n) = \Theta(n^{\log_ba} \log^{k + 1}n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1834479999999998em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mop mtight">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.23015999999999992em;"><span style="top:-2.2341314285714287em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.26586857142857145em;"><span></span></span></span></span></span></span><span class="mspace mtight" style="margin-right:0.19516666666666668em;"></span><span class="mord mathdefault mtight">a</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9334479999999998em;"><span style="top:-3.14734em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。例如 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mn>2</mn><mi>T</mi><mo>(</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo>)</mo><mo>+</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">T(n) = 2T(\frac{n}{2}) + n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.095em;vertical-align:-0.345em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>（归并排序），复杂度就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi><mo>(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\Theta(n\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。再例如，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>T</mi><mo>(</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo>)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">T(n) = T(\frac{n}{2}) + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.095em;vertical-align:-0.345em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> （二分查找），复杂度就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi><mo>(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\Theta(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p>
<h2 id="基础算法与数据结构">基础算法与数据结构</h2>
<h3 id="排序">排序</h3>
<p>快速排序的最佳实践：</p>
<pre><code class="language-cpp">void quick_sort(int l, int r) {
    if (l &gt;= r) return;

    int pivot = a[(l + r) / 2];
    int i = l - 1, j = r + 1;
    while (i &lt; j) {
        do i++; while (a[i] &lt; pivot);
        do j--; while (a[j] &gt; pivot);
        if (i &lt; j) {
            swap(a[i], a[j]);
        }
    }
    
    quick_sort(l, j);
    quick_sort(j + 1, r);
}
</code></pre>
<p>划分区间时，左边的区间中都是 <code>&lt;= pivot</code> 的数，右边的区间中都是 <code>&gt;= pivot</code> 的数，这个隐含的意思是等于 <code>pivot</code> 的数在左右两个区间都有。</p>
<p>下面证明按照 <code>[l, j]</code> 和 <code>[j + 1, r]</code> 分区不会导致死递归。</p>
<p>本质上，我们需要证明每次递归调用的子数组范围 <code>[l, j]</code> 和 <code>[j + 1, r]</code> 都严格小于原数组 <code>[l, r]</code>（即至少减少一个元素），或者证明两个数组都不为空就好了。</p>
<p>首先，左半边区间 <code>[l, j]</code> 一定不会为空，因为最差的情况就是 <code>l == j</code>。下面只要证明右子数组不为空即可。事实上，<code>i</code> 会先移动到 <code>pivot</code> 或者更左边的第一个 <code>&gt;= pivot</code> 的数字上，<code>j</code> 会先移动到 <code>pivot</code> 或者更右边的某个 <code>&lt;= pivot</code> 的数字上，这又分两种情况：</p>
<ul>
<li>倘若都恰好是 <code>pivot</code>，由于 <code>(l + r) / 2 &lt; r</code>，所以 <code>j &lt; r</code> 一定成立，所以 <code>j + 1 &lt;= r</code> 一定成立，所以 <code>[j + 1, r]</code> 也不为空</li>
<li>倘若至少有一个不是 <code>pivot</code>，说明这个时候一定有 <code>i &lt; j</code>，必然会发生一次交换，然后再分别至少执行一次 <code>i++, j--</code>，这个时候 <code>j</code> 一定移动得 <code>&lt; r</code> 了，所以 <code>j + 1 &lt;= r</code> 一定成立。</li>
</ul>
<p>综上，左子数组和右子数组都不为空，都是原数组严格减小后的结果，所以不会死递归。</p>
<p>代码模板记忆：只要记得代码中全是严格大于和小于号，并记住是以 <code>j</code> 为分割点进行数组划分即可。</p>
<p>以上内容总结自 AcWing 算法基础课。</p>
<h3 id="前中后缀表达式">前/中/后缀表达式</h3>
<h3 id="差分">差分</h3>
<p>主要是二维差分记忆有点模糊。</p>
<p>如何得到差分矩阵？</p>
<pre><code>d[i][j] = a[i][j] - a[i - 1][j] - a[i][j - 1] + a[i - 1][j - 1]
</code></pre>
<p>这个结果并不是很直观。</p>
<p>如何在差分矩阵上做修改？</p>
<p>画一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mo>×</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">3 \times 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 的矩阵，看如何把左上角 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>×</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2 \times 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 的矩阵通过差分变成全 1。</p>
<p>需要：</p>
<pre><code class="language-cpp">d[1][1] += 1;
d[1][3] -= 1;
d[3][1] -= 1;
d[3][3] += 1;
</code></pre>
<p>所以，如果要把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>1</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(x_1, y_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(x_2, y_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的矩阵都加上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">val</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>，需要：</p>
<pre><code class="language-cpp">d[x_1][y_1] += val;
d[x_1][y_2 + 1] -= val;
d[x_2 + 1][y_1] -= val;
d[x_2 + 1][y_2 + 1] += val;
</code></pre>
<p>关于区间加等差数列，笔者有点过于翡透了，推了一段时间公式并没有推出来想要的结果。事实上，在考场上我们也可能会遇到类似的情况。倘若我们真的忘了区间加等差数列的结论了，可以使用如下代码帮我们进行回忆：</p>
<pre><code class="language-cpp">int a[10], b[10], c[10];

void meibao() {
    int s = 3, d = 4;
    for (int i = 2; i &lt;= 6; i++) {
        a[i] += s + (i - 2) * d;
    }

    for (int i = 1; i &lt; 10; i++) {
        printf(&quot;%3d &quot;, a[i]);
    }

    printf(&quot;\n&quot;);

    for (int i = 1; i &lt; 10; i++) {
        b[i] = a[i] - a[i - 1];
        printf(&quot;%3d &quot;, b[i]);
    }

    printf(&quot;\n&quot;);

    for (int i = 1; i &lt; 10; i++) {
        c[i] = b[i] - b[i - 1];
        printf(&quot;%3d &quot;, c[i]);
    }
}
</code></pre>
<p>输出结果为：</p>
<pre><code>  0   3   7  11  15  19   0   0   0 
  0   3   4   4   4   4 -19   0   0 
  0   3   1   0   0   0 -23  19   0 
</code></pre>
<p>通过观察，我们发现一阶差分上规律比较明显，先在 <code>l</code> 处加一个首项，再在 <code>[l + 1, r]</code> 上加公差，最后在 <code>r + 1</code> 上减掉最后一项。为了完成这三个对一阶差分的区间加操作，需要在二阶差分上做 6 次单点修改。</p>
<p>于是，我们归纳出在 <code>[l, r]</code> 上，加一个首项为 <code>s</code>，公差为 <code>d</code> 的等差数列怎么做：</p>
<pre><code class="language-cpp">void add(int l, int r, int s, int d) {
    // t 是最后一项
    int t = s + (r - l) * d;
    c[l] += s;
    c[l + 1] += d - s;
    c[r + 1] -= (t + d);
    c[r + 2] += t;
}
</code></pre>
<p>在考场上，我们写出这个之后，可以再写一个对拍去验证一下，这样就重新发明出了区间加等差数列公式。</p>
<p>事实上，在一阶差分数组上的规律更明显，但是可能得用线段树去维护一阶差分。</p>
<p>由于 NOI 特别把差分这个知识点在新大纲中提出来了，所以在这里做了比较多的总结。</p>
<h3 id="二分查找">二分查找</h3>
<p>虽然我们已经会了下面这个模板：</p>
<pre><code class="language-cpp">while (l + 1 &lt; r) {
    mid = (l + r) &gt;&gt; 1;
    if (check(mid)) {
        l = mid;
    } else {
        r = mid;
    }
}
// 单独判断 l 和 r
</code></pre>
<p>但是有些时候会有人问自己标准二分怎么写，或者直接给你来个程序填空或者捉虫，这个时候就还是得会标准二分。</p>
<p>二分要注意的地方主要有两个：</p>
<ol>
<li>如何不丢/错过解</li>
<li>怎么样能不死递归</li>
</ol>
<p>思考如何避免死递归时，不妨直接考虑最初始的数组长度就是 2，这是最容易死递归的情况。</p>
<p>以手写 <code>lower_bound</code> 为例子，假设我们想找 <code>&gt;= 1</code> 的最小的数的位置，数组是 <code>1 2</code>，则可以这样写：</p>
<pre><code class="language-cpp">while (l &lt; r) {
    mid = (l + r) &gt;&gt; 1;
    if (a[mid] &gt;= 1) {
        r = mid;
    } else {
        l = mid + 1;
    }
}
return a[l];
</code></pre>
<p>为什么这样不会死递归？首先我们应该注意到，由于限制了 <code>l != r</code>，且右移是下取整的（除法是向 0 取整，负数时会有问题），所以一定有 <code>((l + r) &gt;&gt; 1) != r</code>。因此，当 <code>a[mid]</code> 符合题意时，我们令 <code>r = mid</code> 即可，无需减去 1，减掉了会漏解。当 <code>a[mid]</code> 不符合题意时，说明 <code>mid</code> 没用，所以 <code>l = mid + 1</code> 即可。</p>
<p>类似的，还有一个东西叫做 <code>mid = (l + r + 1) &gt;&gt; 1</code>，这个东西是上取整的，所以在 <code>l &lt; r</code> 时 <code>mid != l</code>。如果符合题意时要求区间左端点移动，则可以 <code>l = mid</code>，不符合题意时 <code>r = mid - 1</code>。</p>
<p>以上内容总结自算法竞赛进阶指南。</p>
<h3 id="单调栈">单调栈</h3>
<p>解决各种问题</p>
<h3 id="离散化">离散化</h3>
<p>主要是 <code>map</code> 的大值域离散化</p>
<h2 id="图论">图论</h2>
<h3 id="链式前向星">链式前向星</h3>
<p>先来一份代码：</p>
<pre><code class="language-cpp">// 数据结构
LL h[N], e[M], ne[M], w[M], idx;

// 加边函数
void add(int a, int b, LL c) {
    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx++;
}

// 初始化邻接表
memset(h, -1, sizeof h);
idx = 0;
for (int i = 1; i &lt;= m; i++) {
    LL a, b, c;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
    add(a, b, c);
}

// 遍历 ver 结点的所有邻边，并做 dijkstra 的松弛操作
for (int i = h[ver]; i &gt;= 0; i = ne[i]) {
    int v = e[i];
    if (d[v] &gt; d[ver] + w[i]) {
        d[v] = d[ver] + w[i];
        q.push({d[v], v});
    } 
}
</code></pre>
<p>其中：</p>
<ul>
<li><code>h[i]</code> 存储的是 <code>i</code> 结点的第一条边的编号，注意所有 <code>i</code> 结点的邻边组成一条链表，所以 <code>h[i]</code> 相当于链表入口，一般初始化为 <code>-1</code>，表示链表为空。忘记初始化会 TLE，因为边的编号一直都是 0，跳不出循环。</li>
<li><code>e[id]</code> 指的是编号为 <code>id</code> 的这条边指向的结点。</li>
<li><code>ne[id]</code> 指的是编号为 <code>id</code> 的这条边所在链表的下一条边的 <code>id</code>。</li>
<li><code>add(a, b)</code> 是加边函数，其逻辑是先把指向的结点 <code>b</code> 存到 <code>e[idx]</code> 中，再考虑创建一个新的链表结点，并将其头插到当前链表中作为新的头（<code>ne[idx] = h[a], h[a] = idx++</code>）</li>
</ul>
<h3 id="堆">堆</h3>
<h4 id="二叉堆手写">二叉堆手写</h4>
<h4 id="对顶堆">对顶堆</h4>
<h4 id="反悔贪心">反悔贪心</h4>
<h3 id="带权并查集">带权并查集</h3>
<h3 id="最小环">最小环</h3>
<h3 id="次短路">次短路</h3>
<h3 id="强连通分量">强连通分量</h3>
<p>特别注意，强连通分量并不一定是环，其可能是多个环，所以做题分析时要想清楚到底是要找环还是找强连通分量。</p>
<p>首先看一下 Tarjan 算法。</p>
<p>使用 Tarjan 算法求强连通分量时，我们想的是对于每个点 <code>u</code>，维护两个时间 <code>dfn[u]</code> 和 <code>low[u]</code>。其中 <code>dfn[u]</code> 为 <code>u</code> 被第一次访问时的 dfs 时间戳，也就是 dfs 序号，<code>low[u]</code> 表示通过 <code>u</code> 能够走到的点里最小的 <code>dfn</code> 值，其初始化为 <code>low[u] = dfn[u]</code>。</p>
<p>这里对 <code>low[u]</code> 做详细的说明，其实其包含两种情况：</p>
<ul>
<li>从 <code>u</code> 可以走到一个之前从来没走过的邻点 <code>v</code>，则显然 <code>low[v]</code> 是可以用来更新 <code>low[u]</code> 的。</li>
<li>从 <code>u</code> 走到一个已经走过的邻点 <code>v</code>，这样又可以分两种情况：
<ul>
<li><code>v</code> 是在结点访问栈里面的，则说明我们往回走到了 <code>u</code> 的祖先 <code>v</code>，成了一个环，当然也可以用 <code>low[v]</code> 更新 <code>low[u]</code>。</li>
<li>（<strong>最难理解的一种情况</strong>）<code>v</code> 被访问过，但是现在不在结点访问栈里面，那么 <code>u</code> 和 <code>v</code> 一定不在同一个强连通分量内。我们反证一下上面这个事情，假如 <code>u</code> 和 <code>v</code> 在同一个强连通分量内，则必然存在一条路径能从 <code>v</code> 走到 <code>u</code>。那么在第一次访问到 <code>v</code> 的时候，假如其到 <code>u</code> 的那条路上的点都没被访问过，则 <code>v</code> 可以一直 DFS 到 <code>u</code>，这时候是 <code>v</code> 在栈中，和不在栈中的条件矛盾；假如其到 <code>u</code> 的那条路上的点有的已经被访问过了，那么 <code>u</code> 一定被更早的点访问过了，这会推出 <code>u</code> 比 <code>v</code> 更早被访问，和条件矛盾。综上，这种情况下 <code>u</code> 和 <code>v</code> 一定不在同一个强连通分量内，无需更新 <code>low[u]</code>。</li>
</ul>
</li>
</ul>
<p>最后弹出强连通分量时，我们要先找到 <code>dfn[u] = low[u]</code> 的点，然后从栈中一直弹，直到弹到这个点，则这部分都是属于 <code>u</code> 为“根”的强连通分量。对于 <code>dfn[u] != low[u]</code> 的点，我们就不能启动弹栈这个操作，因为其不是强连通分量的“根”。</p>
<p><a href="https://www.luogu.com.cn/problem/P2863">模板题</a></p>
<p>代码模板：</p>
<pre><code class="language-cpp">int n, m, timestamp = 0, dfn[N], low[N];
bool vis[N], instk[N];
vector&lt;vector&lt;int&gt;&gt; e(N);
vector&lt;vector&lt;int&gt;&gt; scc;
vector&lt;int&gt; stk;

void tarjan(int u) {
    vis[u] = true;
    stk.push_back(u);
    instk[u] = true;
    dfn[u] = ++timestamp;
    low[u] = dfn[u];

    for (auto v : e[u]) {
        if (!vis[v]) {
            tarjan(v);
            low[u] = min(low[u], low[v]);
        } else if (instk[v]) {
            low[u] = min(low[u], low[v]);
        }
    }

    if (dfn[u] == low[u]) {
        vector&lt;int&gt; s;
        while (true) {
            int v = stk.back();
            stk.pop_back();
            s.push_back(v);
            instk[v] = false;
            if (v == u) {
                break;
            }
        }
        scc.push_back(s);
    } 
}

void meibao() {
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 1; i &lt;= m; i++) {
        int u, v;
        cin &gt;&gt; u &gt;&gt; v;
        e[u].push_back(v);
    }

    for (int i = 1; i &lt;= n; i++) {
        if (!vis[i]) {
            tarjan(i);
        }
    }

    int res = 0;
    for (int i = 0; i &lt; scc.size(); i++) {
        if (scc[i].size() &gt; 1) {
            res++;
        }
    }
    cout &lt;&lt; res &lt;&lt; &quot;\n&quot;;
}
</code></pre>
<h3 id="双连通分量">双连通分量</h3>
<h3 id="割点与割边">割点与割边</h3>
<h3 id="二分图最大匹配">二分图最大匹配</h3>
<h3 id="spfa">SPFA</h3>
<h3 id="欧拉图">欧拉图</h3>
<p>即能否一笔画的图，无向图的话需要每个点的度数都是偶数，有向图的话需要入度 = 出度。</p>
<h2 id="dp">DP</h2>
<h3 id="树形-dp">树形 DP</h3>
<h3 id="重心">重心</h3>
<h3 id="树上背包">树上背包</h3>
<h3 id="数位-dp">数位 DP</h3>
<h2 id="数据结构">数据结构</h2>
<h3 id="表达式树">表达式树</h3>
<h3 id="树状数组基本原理">树状数组基本原理</h3>
<p>lowbit，下标的结构</p>
<h3 id="线段树扩展操作">线段树扩展操作</h3>
<h3 id="动态开点线段树">动态开点线段树</h3>
<h3 id="扫描线">扫描线</h3>
<h2 id="数学">数学</h2>
<h3 id="约数函数">约数函数</h3>
<p>我们记一个数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的约数个数为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">d(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">d(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 称为约数函数。显然，一个数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的约数个数不会超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><msqrt><mi>n</mi></msqrt><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2\sqrt{n} + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.23972em;"></span><span class="mord">2</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">n</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，但这是一个很粗糙的估计，这种粗糙的估计会让我们对一些算法的复杂度做出错误的估计。</p>
<p>在做题时，真正有用的是我们要知道 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 在一定范围内的时候，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">d(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 最大可能的值。比如：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">n \le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>，则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">d(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 最大只有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>128</mn></mrow><annotation encoding="application/x-tex">128</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">8</span></span></span></span>，我们可以打表打出来发现是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mn>83160</mn></mrow><annotation encoding="application/x-tex">n = 83160</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span><span class="mord">3</span><span class="mord">1</span><span class="mord">6</span><span class="mord">0</span></span></span></span> 时取到，显然 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>12</mn><msup><mn>8</mn><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">128^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord"><span class="mord">8</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> 比 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 还小不少。</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>7</mn></msup></mrow><annotation encoding="application/x-tex">n \le 10^7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span>，则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">d(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 最大只有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>448</mn></mrow><annotation encoding="application/x-tex">448</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">4</span><span class="mord">8</span></span></span></span>，在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mn>8648640</mn></mrow><annotation encoding="application/x-tex">n = 8648640</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span><span class="mord">6</span><span class="mord">4</span><span class="mord">8</span><span class="mord">6</span><span class="mord">4</span><span class="mord">0</span></span></span></span> 时取到。</li>
</ul>
<p>假如 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>7</mn></msup></mrow><annotation encoding="application/x-tex">n \le 10^7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span>，做题时我们可以粗糙地将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">d(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 认为是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>500</mn></mrow><annotation encoding="application/x-tex">500</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span></span></span></span>，用这个数去估计计算量。</p>
<h3 id="乘法逆元">乘法逆元</h3>
<h4 id="使用之前特别关注是否存在">使用之前特别关注是否存在</h4>
<p>怎么求倒是小问题，一般来说直接用费马小定理 + 快速幂搞定了。最关键的其实应该是“怎么求”之前的东西，即先判断一道可以用逆元求解的问题，会不会出现逆元不存在的情况。</p>
<p>我们先回忆一下逆元的定义，假如 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>x</mi><mo>≡</mo><mn>1</mn><mo>(</mo><mtext>mod</mtext><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">ax \equiv 1(\text{mod}m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46375em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mopen">(</span><span class="mord text"><span class="mord">mod</span></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>，则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 的乘法逆元。对于某个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>，为了使其乘法逆元 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 存在，需要这个同余方程有解，转化成不定方程就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>m</mi><mi>y</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">ax + my = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 有解，这需要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>gcd</mi><mo>⁡</mo><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>m</mi><mo>)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\gcd(a, m) = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span style="margin-right:0.01389em;">g</span>cd</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，这就是乘法逆元存在的充要条件。</p>
<p><strong>一般来说</strong>，题目中给的模数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 是<strong>素数</strong>，这个时候相当于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 只要不是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 的倍数就好了。特别地，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 的倍数，所以这个时候不存在乘法逆元。什么时候会出现倍数的情况呢？假如有一个要求乘法逆元的数有可能比 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 大，且这个数的来历可能是一堆数加减乘除得到的，则不排除这个数是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 的倍数的可能。但我们用乘法逆元最多的情况是求组合数，组合数中是对一阶乘求逆元，而只要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>&lt;</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n &lt; m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>，就必然有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>gcd</mi><mo>⁡</mo><mo>(</mo><mi>n</mi><mo>!</mo><mo separator="true">,</mo><mi>m</mi><mo>)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\gcd(n!, m) = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span style="margin-right:0.01389em;">g</span>cd</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">!</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，因为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 中都没有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 这个素因子。</p>
<p>有时候给的模数为合数，或者可能要输入模数，这时候就更要格外小心逆元不存在的情况了。</p>
<p>事实上，我们应该把乘法逆元仍然按照除法去思考，除法是不能除 0 的，所以也不能求 0 的乘法逆元，就算算出了一个所谓的“乘法逆元”，也是错误的，这在除法中本该报出除 0 异常，但使用乘法逆元就会把这个本该抛异常导致程序崩溃的错误，变成一个<strong>悄悄的可以继续执行的错误</strong>，这种问题就会很难排查。</p>
<h4 id="一个不存在的例子">一个不存在的例子</h4>
<p>有一个比较典型的容易犯错的例子，给一个数组 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>，我们想求去掉里面某个数之后，剩下的数字的乘积，则我们很容易想到两种方案：</p>
<ul>
<li>前后缀分解，直接用剩下的前缀和后缀的乘积相乘即可。</li>
<li>预处理所有数的乘积，每次询问除去去掉的那个数（即乘以逆元）。</li>
</ul>
<p>对于第一种方法，完全没用到逆元，所以无需担心。对于第二种方法，不妨设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>=</mo><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">a = [1, 2, 0, 3, 4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mclose">]</span></span></span></span>，假如去掉的是 0，由于最开始预处理所有的数的乘积就是 0，所以按照这种做法算出来剩下的数的乘积还是 0，但实际上应该是 24，这就错了。</p>
<h3 id="exgcd">exgcd</h3>
<p>主要是分析如何求通解。</p>
<p>假设现在已经得到了一组 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi><mo>=</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">ax + by = c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span> 的特解 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>x</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>0</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(x_0, y_0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，则考虑 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 最少变化多少，还能使得解出来的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 是整数。</p>
<p>不妨设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 最少变化 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">d_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，能够让 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 还是整数，且 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 的变化是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">d_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，则有：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi><mo>=</mo><mi>a</mi><mo>(</mo><mi>x</mi><mo>+</mo><msub><mi>d</mi><mn>1</mn></msub><mo>)</mo><mo>+</mo><mi>b</mi><mo>(</mo><mi>y</mi><mo>−</mo><msub><mi>d</mi><mn>2</mn></msub><mo>)</mo><mo>=</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">ax + by = a(x + d_1) + b(y - d_2) = c
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span></span></p>
<p>也就是说</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><msub><mi>d</mi><mn>1</mn></msub><mo>=</mo><mi>b</mi><msub><mi>d</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">ad_1 = bd_2
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">b</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>所以有</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mn>2</mn></msub><mo>=</mo><mfrac><mrow><mi>a</mi><msub><mi>d</mi><mn>1</mn></msub></mrow><mi>b</mi></mfrac></mrow><annotation encoding="application/x-tex">d_2 = \frac{ad_1}{b}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">b</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>我们想求最小的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">d_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，使得 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">d_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 也是整数，则要求 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><msub><mi>d</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">ad_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 的倍数，而 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><msub><mi>d</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">ad_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 显然是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 的倍数，所以要：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><msub><mi>d</mi><mn>1</mn></msub><mo>=</mo><mtext>lcm</mtext><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">ad_1 = \text{lcm}(a, b)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">lcm</span></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></span></p>
<p>也就是：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mn>1</mn></msub><mo>=</mo><mfrac><mrow><mtext>lcm</mtext><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo></mrow><mi>a</mi></mfrac></mrow><annotation encoding="application/x-tex">d_1 = \frac{\text{lcm}(a, b)}{a}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.113em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">lcm</span></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的通解就是</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><msub><mi>x</mi><mn>0</mn></msub><mo>+</mo><mi>k</mi><msub><mi>d</mi><mn>1</mn></msub><mo separator="true">,</mo><mi>k</mi><mo>∈</mo><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">x = x_0 + kd_1, k \in \Z
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">Z</span></span></span></span></span></span></p>
<p>对于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 可以类似地得到结果。</p>
<h3 id="扩展中国剩余定理excrt">扩展中国剩余定理（excrt）</h3>
<p>我们直接跳过普通版中国剩余定理，因为其功能完全是扩展版的子集，且算法的逻辑很不一样。</p>
<p>扩展中国剩余定理的核心在于不断将现有的两个同余方程合并成一个，直到只剩下一个同余方程，此时我们也就解出了同余方程组的通解。</p>
<p>我们分析如何对如下两个方程组进行合并：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">{</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>x</mi><mo>≡</mo><msub><mi>r</mi><mn>1</mn></msub><mo>(</mo><mtext>mod </mtext><msub><mi>m</mi><mn>1</mn></msub><mo>)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>x</mi><mo>≡</mo><msub><mi>r</mi><mn>2</mn></msub><mo>(</mo><mtext>mod </mtext><msub><mi>m</mi><mn>2</mn></msub><mo>)</mo></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{cases}
x \equiv r_1 (\text{mod }m_1)\\
x \equiv r_2 (\text{mod }m_2)
\end{cases}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord text"><span class="mord">mod </span></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord text"><span class="mord">mod </span></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>先将其转化为带余除法的形式：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">{</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>x</mi><mo>=</mo><msub><mi>k</mi><mn>1</mn></msub><msub><mi>m</mi><mn>1</mn></msub><mo>+</mo><msub><mi>r</mi><mn>1</mn></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>x</mi><mo>=</mo><msub><mi>k</mi><mn>2</mn></msub><msub><mi>m</mi><mn>2</mn></msub><mo>+</mo><msub><mi>r</mi><mn>2</mn></msub></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{cases}
x = k_1m_1 + r_1\\
x = k_2m_2 + r_2
\end{cases}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>进而有：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mn>1</mn></msub><msub><mi>m</mi><mn>1</mn></msub><mo>−</mo><msub><mi>k</mi><mn>2</mn></msub><msub><mi>m</mi><mn>2</mn></msub><mo>=</mo><msub><mi>r</mi><mn>2</mn></msub><mo>−</mo><msub><mi>r</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">k_1m_1 - k_2m_2 = r_2 - r_1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>这是关于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">k_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">k_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的二元一次方程，其他量都是已知的，所以我们可以使用 exgcd 先求出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">k_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的一个特解 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">k_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，并得到通解为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mn>1</mn></msub><mo>=</mo><msub><mi>k</mi><mn>0</mn></msub><mo>+</mo><mi>t</mi><mo>×</mo><mfrac><mrow><mtext>lcm</mtext><mo>(</mo><msub><mi>m</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>m</mi><mn>2</mn></msub><mo>)</mo></mrow><msub><mi>m</mi><mn>1</mn></msub></mfrac></mrow><annotation encoding="application/x-tex">k_1 = k_0 + t\times \frac{\text{lcm}(m_1, m_2)}{m_1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69841em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.4550999999999998em;vertical-align:-0.44509999999999994em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">lcm</span></span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.44509999999999994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>。</p>
<p>我们把这个通解代入回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><msub><mi>k</mi><mn>1</mn></msub><msub><mi>m</mi><mn>1</mn></msub><mo>+</mo><msub><mi>r</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x = k_1m_1 + r_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，得到：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mo>(</mo><msub><mi>k</mi><mn>0</mn></msub><mo>+</mo><mi>t</mi><mo>×</mo><mfrac><mrow><mtext>lcm</mtext><mo>(</mo><msub><mi>m</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>m</mi><mn>2</mn></msub><mo>)</mo></mrow><msub><mi>m</mi><mn>1</mn></msub></mfrac><mo>)</mo><mo>×</mo><msub><mi>m</mi><mn>1</mn></msub><mo>+</mo><msub><mi>r</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x = (k_0 + t\times \frac{\text{lcm}(m_1, m_2)}{m_1})\times m_1 + r_1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69841em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.263em;vertical-align:-0.8360000000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">lcm</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>注意到这个式子中，只有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span> 是未知的，其他的都是已知的，进一步整理有：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mi>t</mi><mo>×</mo><mtext>lcm</mtext><mo>(</mo><msub><mi>m</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>m</mi><mn>2</mn></msub><mo>)</mo><mo>+</mo><msub><mi>k</mi><mn>0</mn></msub><msub><mi>m</mi><mn>1</mn></msub><mo>+</mo><msub><mi>r</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x = t\times \text{lcm}(m_1, m_2) + k_0m_1 + r_1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69841em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">lcm</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>这个方程和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><msub><mi>k</mi><mn>1</mn></msub><msub><mi>m</mi><mn>1</mn></msub><mo>+</mo><msub><mi>r</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x = k_1m_1 + r_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 形式很像，这意味着我们把最开始的两个方程，合并成了一个形式很像的方程。</p>
<p>落实到代码上，我们的合并方程函数相当于接收 4 个参数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>r</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>m</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>r</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>m</mi><mn>2</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(r_1, m_1, r_2, m_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，即接收两个方程，最终返回两个参数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>r</mi><mo separator="true">,</mo><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(r, m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>，即一个新的方程，其中：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">{</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>r</mi><mo>=</mo><msub><mi>k</mi><mn>0</mn></msub><msub><mi>m</mi><mn>1</mn></msub><mo>+</mo><msub><mi>r</mi><mn>1</mn></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>m</mi><mo>=</mo><mtext>lcm</mtext><mo>(</mo><msub><mi>m</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>m</mi><mn>2</mn></msub><mo>)</mo></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{cases}
r = k_0m_1 + r_1\\
m = \text{lcm}(m_1, m_2)
\end{cases}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord text"><span class="mord">lcm</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">k_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 需要使用 exgcd 计算，这个地方可能会触发无解，无解可以直接返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(0, 0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span>。</p>
<p>把所有方程合并后，对于最终返回的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>r</mi><mo separator="true">,</mo><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(r, m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>，事实上就是方程：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>≡</mo><mi>r</mi><mo>(</mo><mtext>mod </mtext><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">x \equiv r(\text{mod }m)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46375em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord text"><span class="mord">mod </span></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></span></p>
<p>所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的最小正整数解就是：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo>=</mo><mo>(</mo><mi>r</mi><mtext> mod </mtext><mi>m</mi><mo>+</mo><mi>m</mi><mo>)</mo><mtext> mod </mtext><mi>m</mi></mrow><annotation encoding="application/x-tex">x_{min} = (r \text{ mod }m + m)\text{ mod }m
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord text"><span class="mord"> mod </span></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mord text"><span class="mord"> mod </span></span><span class="mord mathdefault">m</span></span></span></span></span></p>
<p>代码模板：</p>
<pre><code class="language-python">import sys

input = lambda: sys.stdin.readline().rstrip()

n = int(input())
rs = list(map(int, input().split()))
ms = list(map(int, input().split()))

def exgcd(a, b):
    if b == 0:
        return a, 1, 0

    g, xx, yy = exgcd(b, a % b)
    t = xx
    x = yy
    y = t - (a // b) * x
    return g, x, y

def gcd(a, b):
    if b == 0:
        return a
    return gcd(b, a % b)

def lcm(a, b):
    return a // gcd(a, b) * b

def combine_equation(r1, m1, r2, m2):
    g, x, y = exgcd(m1, m2)
    if (r2 - r1) % g != 0:
        return (0, 0)

    k0 = x * (r2 - r1) // g
    return (k0 * m1 + r1, lcm(m1, m2))

res = (rs[0], ms[0])
for i in range(1, n):
    res = combine_equation(res[0], res[1], rs[i], ms[i])

if res[0] == 0 and res[1] == 0:
    print(&quot;-1&quot;)
else:
    r, m = res[0], res[1]
    print((r % m + m) % m)
</code></pre>
<p>为什么这里给出的是 python 模板呢？因为这个算法是有可能出现最终结果不爆 <code>long long</code>，但中间过程爆 <code>long long</code> 的。要想彻底避免这种情况，应该使用龟速乘，但是我有点懒得写，所以直接 python 了。</p>
<h3 id="线性筛求积性函数">线性筛求积性函数</h3>
<h3 id="卡特兰数">卡特兰数</h3>
<h3 id="斯特林数">斯特林数</h3>
<h2 id="字符串">字符串</h2>
<h3 id="manacher">Manacher</h3>
<pre><code class="language-cpp">// s 长度为 n，则 N 至少是 2 * n + 3
const int N = 1e7 + 10;

struct Manacher {
    string t;
    
    /*
    改造后字符串的以 i 为中心的最长回文串的半径
    例如 aba 的半径是 2
    half_len[i] - 1 恰好就是原串中以 i 为中心的回文串的最长长度
    */
    int half_len[N];

    /*
    原串中的 [l, r] 串对应改造串中的 [2 * l + 2, 2 * r + 2]
    对应改造串的中心为 l + r + 2
    half_len[l + r + 2] - 1 &gt;= r - l + 1，说明是回文串
    */
    bool is_palindrome(int l, int r) {
        int mid = l + r + 2;
        return half_len[mid] &gt; r - l + 1; 
    }

    void init(string s) {
        t = &quot;^&quot;;
        for (auto ch : s) {
            t += &quot;#&quot;;
            t += ch;
        }
        t += &quot;#$&quot;;
        
        int n = t.size();
        for (int i = 0; i &lt; n; i++) {
            half_len[i] = 0;
        }

        half_len[1] = 1;
        /*
        box_m: 目前能造成 box_r 最大的回文中心
        box_r: 回文串窗口最右的位置 + 1
        */
        int box_m = 1, box_r = 2;
        for (int i = 2; i &lt; n - 1; i++) {
            int hl = 1;
            /*
            box_m * 2 - i: i 相对于 box_m 的对称位置
            box_r - i: 到达 box_r 以及更右边的部分还没遍历过，不知道是否相等
            */
            if (i &lt; box_r) {
                hl = min(half_len[box_m * 2 - i], box_r - i);
            }
            while (t[i + hl] == t[i - hl]) {
                hl++;
                box_m = i;
                box_r = i + hl;
            }
            half_len[i] = hl;
        }
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用Python打算法竞赛的小技巧（持续更新）]]></title>
        <id>https://BUAA-Wander.github.io/post/python-in-competitive-programming/</id>
        <link href="https://BUAA-Wander.github.io/post/python-in-competitive-programming/">
        </link>
        <updated>2025-08-20T08:30:34.000Z</updated>
        <content type="html"><![CDATA[<p>使用 Python 打算法竞赛似乎一直以来不被看好，原因主要是 Python 本身的运行效率不如 C++（尤其是只提供 CPython 时），且容易在一些好用的 API 或包的诱惑下写出<strong>大常数</strong>代码，在算法竞赛这个寸时寸金的领域稍有不慎就会 TLE。有些题可能 C++ 放过了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 的做法，但 Python 必须写 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 做法才能过。随着时代的发展，编程的普及，越来越多的朋友使用 Python 写算法题，然后就不得不直面 Python 慢的问题。在这个过程中，大家探索出了很多可以让 Python 跑得更快的实现技巧，Python 逐渐地在一些题型上有了一战之力，在蓝桥杯等比赛中甚至也出现了只能使用 Python 的组别。</p>
<p>本文主要介绍 Python 在做算法题时如何减小 Python 代码的常数（因为讲基本用法的文章网上已经有很多了），从而有可能通过更多的题目。假如比赛环境中支持多种语言，但 Python 并没有提供 PyPy 的话，最好还是别用 Python 了，老老实实用 C++ 吧。</p>
<h2 id="输入输出">输入输出</h2>
<h3 id="输入">输入</h3>
<p>一般情况下，使用 <code>input()</code> 函数就可以了，常见的输入模式：</p>
<pre><code class="language-python"># 单个数读入
n = int(input())
# 同行读入若干个数
n, k = map(int, input().split())
# 同行读入一个数组
a = list(map(int, input().split()))
# 同行读入一个数组，并且强行以 1 作为起始下标（如果你更习惯 1 作为起始下标）
a = [0] + list(map(int, input().split()))
</code></pre>
<p>但是，在需要大量输入数据的题目中，<code>input</code> 会处理内置的输入缓冲（包括提示符、换行处理等），直接使用 <code>input()</code> 函数就会 TLE 了，这个时候我们需要加这样一行代码：</p>
<pre><code class="language-python">input = lambda: sys.stdin.readline().strip()
</code></pre>
<p>加上它之后，后边的读入代码完全不用变。</p>
<p><code>sys.stdin.readline()</code> 更快，因为它直接使用系统级输入读取，但是保留了换行符，需要 <code>strip()</code> 去掉。</p>
<h3 id="输出">输出</h3>
<p>主要是使用 <code>print()</code> 函数，但是每调用一次 <code>print()</code> 函数就是一次 I/O 操作，I/O 操作过多会导致速度变慢。</p>
<p>我们考虑以下代码：</p>
<pre><code class="language-python">n = int(4e6)

for i in range(1, n + 1):
    print(i)
</code></pre>
<p>在 Codeforces custom invocation 中，使用 PyPy 3.10 进行测试，其运行了 687ms，多次运行均差不多是这些。</p>
<p>如果我们把所有的输出塞到列表里，最后统一输出：</p>
<pre><code class="language-python">n = int(4e6)
res = []
for i in range(1, n + 1):
    res.append(i)
print('\n'.join(map(str, res)))
</code></pre>
<p>需要 468ms，多次测试均差不多是这些。</p>
<p>上面只是一个简单的例子。事实上，在其他的需要大量输出的场景下，把输出最后统一进行总是会快一些。因此，在<strong>内存允许</strong>的情况下，可以把数据结构题或者多测题的输出攒起来，最后调用一次 <code>print()</code> 函数一起输出，能够提升一些速度。</p>
<p>在<a href="https://codeforces.com/gym/105973/problem/C">本题</a>中，调用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span> 次 <code>print</code> 输出会超时，使用上面的方法拼接起来之后输出可以通过。</p>
<h2 id="排序">排序</h2>
<p>对于一般的整数数组，我们可以直接使用 <code>nums.sort()</code> 进行排序。</p>
<p>有时候我们需要对一些复杂对象的列表进行排序，这个时候我们通过定义比较函数，使用 <code>cmp_to_key</code> 将比较函数转化为 <code>key</code> 之后进行排序即可。</p>
<p>从实践上来说，通过指定 <code>key</code> 直接对复杂对象列表排序会带来很多拷贝的开销，导致速度变慢很多。</p>
<p>这时，我们考虑另一个思路：我们初始化一个下标列表 <code>[1, n]</code>，然后对下标列表进行排序，排序的 <code>key</code> 中使用了复杂对象列表中的数据。这样之后，我们会得到一个下标列表，按照这个列表从左往右遍历，这些下标对应的复杂对象列表中的数据就是排序后的顺序。</p>
<p>看一份代码理解一下吧。这里是把元组 <code>(x, y)</code> 按照 x 从小到大排序，y 的顺序不关心，使用对下标排序的方案实现：</p>
<pre><code class="language-python">m = int(input())
xs = []
ys = []
for i in range(m):
    x, y = map(int, input().split())
    xs.append(x)
    ys.append(y)
 
order = [i for i in range(m)]
order = sorted(order, key=lambda i: xs[i])
</code></pre>
<p>由于不涉及原数据的修改，所以我们甚至不需要真的使用元组去存，而是可以直接俩 list 对齐去存储。</p>
<p>对下标进行排序的方案我们只是对一个整数数组进行的排序，得到的相当于复杂对象列表的一个<strong>排序视图</strong>，除了快之外，我们还可以在原列表的基础上按照不同的排序规则导出多个排序视图。</p>
<p>关于排序的一道例题可以看 <a href="https://codeforces.com/contest/652/problem/C">CF652C</a>。在本题中，你可以清楚地感知到快速读入、复杂对象排序、哈希等对 Python 运行速度的影响。</p>
<h2 id="多维数组">多维数组</h2>
<p>Python 实现类似多维数组的东西，最直观的写法是 list 套 list。但这个东西非常慢，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mn>5000</mn></mrow><annotation encoding="application/x-tex">n=5000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 有时候都会寄。list 第一维远大于第二维的时候（例如某些 ST 表或倍增的写法），很容易出现类似 C++ 的 Cache miss 的现象，且慢得更加明显。</p>
<p>在 DP 时，能用滚动数组就用滚动数组，这样少一维不只是空间优化了，时间也能快一些。</p>
<p><a href="https://codeforces.com/gym/105582/problem/C">CF105582C</a>，本题不使用滚动数组的话二进制拆分的多重背包跑不过去，用了之后才能过去。</p>
<p>list 套 list 还可以考虑拍平成一维的 list（这正好是 C 语言编译时对高维数组的处理方式），可以写一个下标变换函数 <code>f</code>，把 <code>dp[i][j][k]</code> 这种高维下标变成一维下标 <code>dp[f(i, j, k)]</code>。</p>
<p>拍平下标转化也是有时间开销的。如果是 DP 场景的话，可能只涉及加法和乘法，开销还好。但有的题需要用除法和取模去把一维下标还原成多维下标，这个时候就不太好说了。</p>
<h2 id="手写工具函数">手写工具函数</h2>
<p>在 LeetCode 周赛中，经常有朋友发现因为使用了 <code>max</code> 之类的函数而超时，这个时候需要改成手写 <code>fmax</code> 函数才能通过：</p>
<pre><code class="language-python">fmax = lambda a, b: a if a &gt; b else b
</code></pre>
<p>这个坑点在 LeetCode 上最明显，说是能差出 3 倍；在 Codeforces 上我测试时感觉差别比较小。</p>
<blockquote>
<p>值得一提的是，我在 Codeforces 上测试 <code>max</code> 时，对于相同的代码，选择 Python 3.10 和选择 PyPy 3 运行的时间分别是 600+ms 和 93ms，可见 PyPy 3 在算法竞赛中对 Python 有多重要。</p>
</blockquote>
<p>有时候 <code>max</code> 只是让程序 TLE 的最后一根稻草，或已经 TLE 之后的雪上加霜，这时候还需要看其他地方有没有可以优化的点。</p>
<h2 id="非递归">非递归</h2>
<h3 id="树相关问题的非递归">树相关问题的非递归</h3>
<p>直接使用 DFS 进行树的遍历，很有可能会爆栈 RE，改了栈空间大小可能也不好使（TLE MLE RE 快乐三选一）。有人说我们可以写 BFS 遍历呀，但是有时候我们就是需要按照自底向上的那个顺序去遍历结点（比如需要利用子树信息更新本结点信息的树形 DP），所以我们还是要想办法知道 DFS 的结点遍历顺序。</p>
<p>注意到 BFS 是一层一层访问的，其访问顺序反过来的话，是一种合理的自底向上的顺序，所以我们使用 BFS 去遍历树，得到一个序列 <code>order</code>，并记录 BFS 时每个结点的父亲，然后按照 <code>order</code> 的反序去遍历，就可以自底向上去做一些事情（子结点信息更新父亲信息）；按照 <code>order</code> 的正序遍历，则可以自顶向下做一些事情（父结点信息更新子结点信息）。</p>
<p>代码如下：</p>
<pre><code class="language-python">q = []
order = []
q.append(1)
parent = [-1 for _ in range(n + 1)]
parent[1] = 0
front = 0
while front &lt; len(q):
    u = q[front]
    front += 1
    order.append(u)
    for v in e[u]:
        if parent[v] == -1:
            parent[v] = u
            q.append(v)

reversed_order = order[::-1]

for u in reversed_order:
    ...
 
</code></pre>
<p>事实上，可以直接用 <code>order</code> 作为 BFS 的队列，无需单独开一个 <code>q</code>。</p>
<p>掌握了该项技能，就又可以过很多题了。</p>
<h2 id="图论题">图论题</h2>
<p>说实话，python 好多图论题就是过不了，我这里随便放几个遇到的题目：</p>
<p><a href="https://codeforces.com/gym/106157/problem/F">Problem - F - Codeforces</a></p>
<h2 id="数据结构">数据结构</h2>
<h2 id="对-python-速度的正确感知">对 Python 速度的正确感知</h2>
<h2 id="作用域相关的坑">作用域相关的坑</h2>
<h2 id="参考文献">参考文献</h2>
<ul>
<li>灵茶山艾府、小羊肖恩、conqueror_of_tourist 等经常使用 Python 做题/讲题的大佬的 AC 代码。</li>
<li>算法交流群里关于 Python 使用的聊天记录。</li>
<li>本人的实践经验。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在Codeforces随机刷题一年半，我学到了什么]]></title>
        <id>https://BUAA-Wander.github.io/post/what-did-i-learn-from-codeforces/</id>
        <link href="https://BUAA-Wander.github.io/post/what-did-i-learn-from-codeforces/">
        </link>
        <updated>2025-08-19T05:02:37.000Z</updated>
        <content type="html"><![CDATA[<h2 id="随机刷题前的我是什么样子">随机刷题前的我是什么样子</h2>
<p>笔者中学没有参与过信息学竞赛，大学没有参与过校级以上的 XCPC 相关赛事，为数不多的线下比赛经验是蓝桥杯以及 XCPC 校赛，最好战绩 C++ 研究生组北京省冠+国二（未公布 PDF 不知道具体名次），因此只能勉强算是一个算法爱好者。</p>
<p>笔者在 2024 年 1 月之前的情况大约如下：</p>
<ul>
<li>知识点：学完了 AcWing 算法基础+提高课以及算法竞赛进阶指南上 80% 左右的算法，还学了少量事实上对我来说 useless 的高级数据结构以及数学算法。平时做题主要是按照题单去做（即使是之前已经学过这个知识点了），即带着题目解法的提示去做题。</li>
<li>奖项：大四时拿了蓝桥杯 C++ A 组北京省一中游，时间冲突未参与国赛，有一定的写暴力的能力。</li>
<li>线上比赛：CF 1600 分的题目对我来说是个坎，需要 30 分钟以上才有可能做出来，但大部分时候是思路完全卡死做不出来。我从 2022 年底一直到 2023 年底，一年的时间都没在这个难度上有所突破。</li>
</ul>
<p>读者们应该发现了一个事实：我学习的知识点和表现出的解题能力差距有些大。从我现在的角度来看，24年初那会儿掌握的算法足够我去做 95% 以上的 2100 分以内的题目了，但我当时居然还经常被 1600 分的题目卡，着实有点搞笑了。</p>
<h2 id="开始改变训练方式">开始改变训练方式</h2>
<p>24 年 1 月，偶然间加入了<strong>小羊肖恩</strong>以及<strong>灵茶山艾府</strong>的算法交流群，两个群的每日活动都是写 CF，羊村是每日两羊蹄，灵茶山是每日一杯茶，题目的难度如下：</p>
<table>
<thead>
<tr>
<th>星期</th>
<th>羊村难度</th>
<th>灵茶山难度</th>
</tr>
</thead>
<tbody>
<tr>
<td>星期一</td>
<td>1800 1900</td>
<td>1300-1400</td>
</tr>
<tr>
<td>星期二</td>
<td>1800 1900</td>
<td>1400-1500</td>
</tr>
<tr>
<td>星期三</td>
<td>1700 2000</td>
<td>1600-1800</td>
</tr>
<tr>
<td>星期四</td>
<td>1700 2000</td>
<td>1900-2100</td>
</tr>
<tr>
<td>星期五</td>
<td>1600 2100+</td>
<td>2400+</td>
</tr>
<tr>
<td>星期六</td>
<td>1600 2200+</td>
<td>休息</td>
</tr>
<tr>
<td>星期日</td>
<td>休息</td>
<td>休息</td>
</tr>
</tbody>
</table>
<p>由于 CF 上的题我做的很差，所以最开始每日的活动我参与得非常吃力：羊蹄很多时候当天只能完成一道，周四周五的茶对我来说也颇有挑战，尤其是周五的茶我大部分时候是不做的。后面羊蹄开了专门的 GitHub 仓库，在连续打卡的激励下，我开始稳定地每日完成至少一道羊蹄，虽然只是写 1600-1800 分的题目，但这个分数已经是我 rating + 200 到 400 的题目了，所以做下来仍然可以有所进步。</p>
<h2 id="不断突破自我">不断突破自我</h2>
<p>熬过去了两个多月，在这样写了 200 题之后，思考时有了明显的进步。我发现 1600 分的题目 10 道里我可能只有一两道不会了，1800 分左右的题目我有时候也可以自己想出来了。之后的一段时间里，我开始尝试每日啃两道羊蹄，茶也争取周一到周四全勤，周五的题至少看一看（不止一位大佬在群里说过，什么题都可以先花几分钟看一看，再决定做不做）。</p>
<p>到了五六月份的时候，我的 LeetCode 周赛打到了 2500 多分，相比于一年前停滞不前的 2300 多分，可以感觉出来有一些进步，但说不清楚进步在哪里了，因为我觉得自己这半年并没有学到什么新的算法，似乎只是“注意力”有了一些提升，能够发现之前发现不了的切入点。</p>
<p>又经过了一个暑假的积累，到了 2024 年 10 月，我的 CF 总题量达到了 1000 题，其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≥</mo></mrow><annotation encoding="application/x-tex">\ge</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≥</span></span></span></span> 1500 的题 637 道，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≥</mo></mrow><annotation encoding="application/x-tex">\ge</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≥</span></span></span></span> 1800 的题 293 道，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≥</mo></mrow><annotation encoding="application/x-tex">\ge</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≥</span></span></span></span> 2000 的题 120 道。这个时候，我能明显感觉到自己找切入点时的“注意力”吊打进群前的自己。在这段时间，我参与了一场 CF div2 的比赛，在这之前我已经一年没有打 rated 比赛了。在这场比赛中，我解决了 ABC1E1 4 道题目，并且由于 E1 解决的时间比较早，导致我这场的表现分达到了惊人的 2160 分！在这之前我最好的发挥仅仅是 AK div4 打到1700 左右的蓝名表现分。这时，我是确信自己是真的进步了，并且我相信按照这个训练计划继续走，我还有不小的提升空间。</p>
<p>2024 年 11 月，我第 4 次参与校赛，在预赛解决了 9 题，排名前 20，后面的决赛解决了 7 题（共 9 题），排名第 7，拿到了校赛一等奖，在此之前我最好成绩是校赛 20 多名三等奖。线下的比赛是很有说服力的，我能和那些搞过 OI 的同学在校赛的赛制和难度下能打得有来有回了，这给了我很大的信心。另外从平时训练情况上来看，我似乎可以比较稳地在非赛时吃掉 1800 分以内题目了，2000 分以内的题目也经常有一战之力。</p>
<p>2025 年 4 月蓝桥杯省赛，我成功 AK，拿到了研究生组的第一名，又一次线下赛的成功经历。6 月国赛打得确实下饭了，或许是起得太早去考场导致脑子昏昏沉沉，也可能是水平确实还没到，最后只拿了国二。</p>
<p>之后，就很少有线下线上比赛的经历了，线上没比赛主要是晚上睡得比较早，所以不参加 CF 的比赛（之前晚上参加打得非常下饭，只能打出 1700 不到的表现）。在水群时，有几位橙名的群友有说我现在的水平应该回归打几场比赛就有紫名了，但可惜目前作息实在是不太适合打。或许等后边作息发生一些变化时可以冲一冲，作为爱好者咱也是希望能上个紫的，至于橙名，目前我感觉自己的水平还够不到，我自己平时单题训练时都还没有稳定切掉 2000 分以及以上题目的能力。</p>
<p>附上我目前的训练情况截图：</p>
<figure data-type="image" tabindex="1"><img src="https://BUAA-Wander.github.io/post-images/1755584273526.png" alt="训练情况" loading="lazy"></figure>
<h2 id="增加套路的学习和积累">增加套路的学习和积累</h2>
<p>TODO，做 ABC</p>
<h2 id="到目前为止的收获">到目前为止的收获</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2025年8月算法好题集锦]]></title>
        <id>https://BUAA-Wander.github.io/post/2025-08-good-problems/</id>
        <link href="https://BUAA-Wander.github.io/post/2025-08-good-problems/">
        </link>
        <updated>2025-08-19T03:56:53.000Z</updated>
        <content type="html"><![CDATA[<p>Codeforces：</p>
<table>
<thead>
<tr>
<th>题目链接</th>
<th>难度分</th>
<th>Tag</th>
<th>题解</th>
<th>学到的东西</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://codeforces.com/contest/1896/problem/E">CF1896E</a></td>
<td>2100</td>
<td>破环为链、树状数组</td>
<td>---</td>
<td>---</td>
</tr>
<tr>
<td><a href="https://codeforces.com/contest/1913/problem/E">CF1913E</a></td>
<td>2400</td>
<td>网络流建模</td>
<td>---</td>
<td>将所有边权同时加同一个数使得所有边权为正</td>
</tr>
<tr>
<td><a href="https://codeforces.com/contest/271/problem/E">CF271E</a></td>
<td>2200</td>
<td>数论、构造</td>
<td>---</td>
<td>---</td>
</tr>
<tr>
<td><a href="https://codeforces.com/contest/1041/problem/E">CF1041E</a></td>
<td>2200</td>
<td>树、构造</td>
<td>---</td>
<td>---</td>
</tr>
<tr>
<td><a href="https://codeforces.com/contest/652/problem/C">CF652C</a></td>
<td>1800</td>
<td>排序</td>
<td>---</td>
<td>Python如何实现小常数排序</td>
</tr>
<tr>
<td><a href="https://codeforces.com/contest/2129/problem/C2">CF2129C</a></td>
<td>2000</td>
<td>构造、位运算</td>
<td>---</td>
<td>独热编码</td>
</tr>
<tr>
<td><a href="https://codeforces.com/contest/76/problem/A">CF76A</a></td>
<td>2200</td>
<td>瓶颈生成树</td>
<td>---</td>
<td>---</td>
</tr>
<tr>
<td><a href="https://codeforces.com/contest/1207/problem/F">CF1207F</a></td>
<td>2100</td>
<td>根号分治</td>
<td>---</td>
<td>问题求解的复杂度是两部分的乘积，乘积为定值</td>
</tr>
<tr>
<td><a href="https://codeforces.com/problemset/problem/763/A">CF763A</a></td>
<td>1600</td>
<td>根号分治、树形DP</td>
<td>---</td>
<td></td>
</tr>
<tr>
<td><a href="https://codeforces.com/problemset/problem/203/D">CF203D</a></td>
<td>1700</td>
<td>速度分解</td>
<td>---</td>
<td></td>
</tr>
<tr>
<td><a href="https://codeforces.com/problemset/problem/95/C">CF95C</a></td>
<td>1900</td>
<td>最短路</td>
<td>---</td>
<td>同时涉及到距离和费用，先求最短距离得到关于费用的图，再求费用最短路</td>
</tr>
<tr>
<td><a href="https://codeforces.com/contest/2071/problem/D1">CF2071D1</a></td>
<td>1800</td>
<td>递归</td>
<td>---</td>
<td>手玩，发现消去规律</td>
</tr>
<tr>
<td><a href="https://codeforces.com/contest/201/problem/C">CF201C</a></td>
<td>2000</td>
<td>DP</td>
<td>---</td>
<td>从i点开始走虽然可以来回跨着i折返，但可以转化成不折返，所以只需考虑不折返</td>
</tr>
<tr>
<td><a href="https://codeforces.com/contest/1463/problem/E">CF1463E</a></td>
<td>2400</td>
<td>缩点、拓扑排序</td>
<td>---</td>
<td>邻接关系显然更强，我们可以把这部分做一个缩点，就可以优先满足这类约束了，24年校赛E题也是这个思路</td>
</tr>
<tr>
<td><a href="https://codeforces.com/problemset/problem/2077/C">CF2077C</a></td>
<td>2300</td>
<td>组合数学、推公式</td>
<td><a href="https://github.com/Yawn-Sean/Daily_CF_Problems/blob/main/daily_problems/2025/08/0829/solution/cf2077c.md">羊的题解</a></td>
<td>首先要观察出每个序列的答案只和01个数有关（介值定理+均值不等式），才有资格进入后续推式子环节。推式子用到了二项式定理+求导的技巧</td>
</tr>
<tr>
<td><a href="https://codeforces.com/contest/332/problem/D">CF332D</a></td>
<td>2400</td>
<td>贡献法</td>
<td><a href="https://github.com/Yawn-Sean/Daily_CF_Problems/blob/main/daily_problems/2025/08/0830/solution/cf332d.md">性质分析</a></td>
<td>比较套路的分析每条边贡献多少次的题目，奇妙之处在于答案可以直接浮点数取整输出表示出来</td>
</tr>
<tr>
<td><a href="https://codeforces.com/contest/1469/problem/E">CF1469E</a></td>
<td>2400</td>
<td>字典序、贪心</td>
<td>---</td>
<td>关键在于发现无解的条件，通过观察样例可以，把存在问题改为任意问题也可以，后边就是套路的按位贪心</td>
</tr>
</tbody>
</table>
<p>AtCoder：</p>
<blockquote>
<p>最近在备赛 CSP-S，打 ABC 复习知识点，感觉 EF 题都挺不错的，能够复习到很多好久不见的技巧，难度上基本是绿题（普及+/提高），对 CSP-S 拿低分省一还是很有用的。</p>
</blockquote>
<table>
<thead>
<tr>
<th>题目链接</th>
<th>难度分</th>
<th>Tag</th>
<th>题解</th>
<th>学到的东西</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://atcoder.jp/contests/abc419/tasks/abc419_e">ABC419E</a></td>
<td>洛谷绿</td>
<td>背包DP</td>
<td>---</td>
<td>需要注意到相距为L的两个元素之间的关系，从而才能转化成分组背包</td>
</tr>
<tr>
<td><a href="https://atcoder.jp/contests/abc418/tasks/abc418_e">ABC418E</a></td>
<td>洛谷黄</td>
<td>哈希、斜率</td>
<td>---</td>
<td>使用GCD并调整符号表示斜率，以及自定义结构使用umap如何写哈希</td>
</tr>
<tr>
<td><a href="https://atcoder.jp/contests/abc417/tasks/abc417_f">ABC417F</a></td>
<td>洛谷绿</td>
<td>期望、线段树</td>
<td>---</td>
<td>期望的线性性</td>
</tr>
<tr>
<td><a href="https://atcoder.jp/contests/abc416/tasks/abc416_e">ABC416E</a></td>
<td>洛谷绿</td>
<td>最短路</td>
<td>---</td>
<td>虚点最短路、加边后松弛操作可以快速更新最短路</td>
</tr>
<tr>
<td><a href="https://atcoder.jp/contests/abc369/tasks/abc369_e">ABC369E</a></td>
<td>洛谷绿</td>
<td>最短路、暴力枚举</td>
<td><a href="https://www.luogu.com.cn/article/468hpmms">沃若的题解</a></td>
<td>一题多解</td>
</tr>
<tr>
<td><a href="https://atcoder.jp/contests/abc366/tasks/abc366_e">ABC366E</a></td>
<td>洛谷绿</td>
<td>推公式</td>
<td></td>
<td>遇到曼哈顿距离并非一定要考虑转切比雪夫距离处理</td>
</tr>
<tr>
<td><a href="https://atcoder.jp/contests/abc406/tasks/abc406_f">ABC406F</a></td>
<td>洛谷绿</td>
<td>DFS序、线段树</td>
<td></td>
<td>板子太久没写了，注意下标</td>
</tr>
<tr>
<td><a href="https://atcoder.jp/contests/abc403/tasks/abc403_f">ABC403F</a></td>
<td>洛谷绿</td>
<td>表达式解析、递归、DP</td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="https://atcoder.jp/contests/abc402/tasks/abc402_f">ABC402F</a></td>
<td>洛谷绿</td>
<td>双向BFS、二分</td>
<td></td>
<td>实现时，可以先搜一边，到某个深度停止，这一边都搜完之后再写另一边的搜索</td>
</tr>
<tr>
<td><a href="https://atcoder.jp/contests/abc389/tasks/abc389_e">ABC389E</a></td>
<td>洛谷蓝</td>
<td>贪心、二分</td>
<td></td>
<td>总代价是关于个数的函数，做差可求得每多拿一件的单价，然后可以贪心去拿</td>
</tr>
<tr>
<td><a href="https://atcoder.jp/contests/abc399/tasks/abc399_f">ABC399F</a></td>
<td>洛谷绿</td>
<td>推公式、二项式定理、求和换序</td>
<td></td>
<td>单独某个数的贡献并不容易算，于是切入点改为枚举右，快速把所有左的结果算出来</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Gridea+GitHub Pages+主题配置踩坑记录]]></title>
        <id>https://BUAA-Wander.github.io/post/gridea-blog-config-tutorial/</id>
        <link href="https://BUAA-Wander.github.io/post/gridea-blog-config-tutorial/">
        </link>
        <updated>2025-08-19T00:24:10.000Z</updated>
        <content type="html"><![CDATA[<h2 id="concise-主题公式出现两次">Concise 主题公式出现两次</h2>
<p>效果类似于把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> 渲染成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>S。</p>
<p>解决方案是将 <code>concise\templates\includes\head.ejs</code> 文件增加这三行内容：</p>
<pre><code class="language-html">&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/katex.min.css&quot;&gt;
&lt;script defer src=&quot;https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/katex.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js&quot; async&gt;&lt;/script&gt;
</code></pre>
<p>其他主题遇到了类似问题也可以尝试这样去修复一下。</p>
<blockquote>
<p>有人问 <code>concise\templates\includes\head.ejs</code> 在哪里？这个可以在 Gridea 中查看站点源文件的存储路径，我的保持了默认路径，大概长这样： <code>C:/Users/WanderOvO/Documents/Gridea</code>。去里面的 <code>themes</code> 目录下找到对应的主题即可，想换主题也是把主题解压在这里。</p>
</blockquote>
<h2 id="concise-主题代码块颜色修改">Concise 主题代码块颜色修改</h2>
<p>你需要修改 <code>concise\assets\styles\components\code-hljs-highlight.less</code> 中的内容。只要知道需要改这个文件，里面该改哪些东西是容易看出来的，实在大不了可以挨个试，或者网上找一份现成的复制粘贴进来，抑或是让 DeepSeek 帮你推荐一些配色方案。</p>
<blockquote>
<p>可以使用 F12 选择对应的元素，在前端直接改 CSS，确定到底是改哪个 CSS 才能起作用，然后去主题文件夹中找到那个文件修改即可。<br>
有的主题的配置可以在 Gridea 客户端的自定义配置页面直接改，比如 Next 主题的，这样就不用自己去翻代码改了（改了可能也被覆盖了没用）。</p>
</blockquote>
<h2 id="github-pages-css-加载不出来文章跳转-404">GitHub Pages css 加载不出来，文章跳转 404</h2>
<p>通过 F12 看前端网络请求，发现是我在 Gridea 中配置的域名错了，导致访问仓库中的文件都是 404。在 Gridea 的远程管理页面需要填一个域名，这个域名指的是<strong>你的博客的域名</strong>，比如 <code>BUAA-Wander.github.io</code>，而<strong>不是你的仓库的地址</strong>，我最开始不小心复制成了仓库的地址，导致 GET 请求一直在请求类似于 <code>https://github.com/BUAA-Wander/BUAA-Wander.github.io/post/article-title</code>  之类的东西，但实际上应该请求 <code>https://BUAA-Wander.github.io/post/article-title</code>，过了很久才反应过来。</p>
<p>写错的时候，默认只能加载出根目录的 <code>index.html</code>，其他的跳转和加载 CSS 的路径都是错的，所以访问文章会 404，CSS 文件也请求不到。</p>
<p>但是不写错域名有时候似乎也会出现 CSS 突然不管用的问题，具体解决方案可以在搜索引擎上搜一下。</p>
<h2 id="各种修改不生效的问题">各种修改不生效的问题</h2>
<p>请打开 F12 开发者模式，<strong>禁用缓存</strong>然后刷新。</p>
<p>如果是 GitHub Pages 修改不生效，除了缓存问题，还有一个原因是<strong>还没部署上</strong>，可以等 2 分钟。</p>
<h2 id="同步到远端失败">同步到远端失败</h2>
<p>可能是网络问题，需要在 Gridea 中配置 https 代理，例如我的梯子需要配置 127.0.0.1:10809</p>
<h2 id="备份与转移">备份与转移</h2>
<p>需要对 <code>C:\Users\WanderOvO\Documents\Gridea</code> 目录进行备份，其中有文章、图片、已经魔改好的博客主题。</p>
]]></content>
    </entry>
</feed>